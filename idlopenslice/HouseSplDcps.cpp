#include "House_DCPS.hpp"

#include <v_copyIn.h>
#include <v_topic.h>
#include <os_stdlib.h>
#include <string.h>
#include <os_report.h>

v_copyin_result
__Mind_House__copyIn(
    c_base base,
    const class ::Mind::House *from,
    struct _Mind_House *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->name = c_stringNew_s(base, from->name_.c_str());
        if(to->name == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->name = c_stringNew_s(base, from->name_.c_str());
            if(to->name == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->targetTemperatureAwaySummer = (c_double)from->targetTemperatureAwaySummer_;
    to->targetTemperatureHolidaySummer = (c_double)from->targetTemperatureHolidaySummer_;
    to->targetTemperatureAwayWinter = (c_double)from->targetTemperatureAwayWinter_;
    to->targetTemperatureHolidayWinter = (c_double)from->targetTemperatureHolidayWinter_;
#ifdef OSPL_BOUNDS_CHECK
    if((((c_long)from->temperatureMode_) >= 0) && (((c_long)from->temperatureMode_) < 3) ){
        to->temperatureMode = (enum _Mind_TemperatureMode)from->temperatureMode_;
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'Mind::House.temperatureMode' of type 'TemperatureMode' is out of range.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->temperatureMode = (enum _Mind_TemperatureMode)from->temperatureMode_;
#endif
    to->automaticWinterSummerSwitch = (c_bool)from->automaticWinterSummerSwitch_;
    to->lowTemperatureThreshold = (c_double)from->lowTemperatureThreshold_;
    to->highTemperatureThreshold = (c_double)from->highTemperatureThreshold_;
#ifdef OSPL_BOUNDS_CHECK
    if((((c_long)from->currentMode_) >= 0) && (((c_long)from->currentMode_) < 6) ){
        to->currentMode = (enum _Mind_HouseMode)from->currentMode_;
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'Mind::House.currentMode' of type 'HouseMode' is out of range.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->currentMode = (enum _Mind_HouseMode)from->currentMode_;
#endif
#ifdef OSPL_BOUNDS_CHECK
    if((((c_long)from->currentState_) >= 0) && (((c_long)from->currentState_) < 12) ){
        to->currentState = (enum _Mind_StateName)from->currentState_;
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'Mind::House.currentState' of type 'StateName' is out of range.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->currentState = (enum _Mind_StateName)from->currentState_;
#endif
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        c_octet *dest0;
        const ::Mind::House::_image_seq *src = &from->image_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "c_octet"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<c_octet>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (c_octet *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const c_octet *buf0;
                buf0 = reinterpret_cast<const c_octet *>(&((*src)[0]));
                memcpy (dest0,buf0,length0* sizeof(*dest0));
            }
            to->image = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (c_octet *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const c_octet *buf0;
                buf0 = reinterpret_cast<const c_octet *>(&((*src)[0]));
                memcpy (dest0,buf0,length0* sizeof(*dest0));
            }
            to->image = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
#ifdef OSPL_BOUNDS_CHECK
        to->holidayStartDate = c_stringNew_s(base, from->holidayStartDate_.c_str());
        if(to->holidayStartDate == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->holidayStartDate = c_stringNew_s(base, from->holidayStartDate_.c_str());
            if(to->holidayStartDate == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->holidayEndDate = c_stringNew_s(base, from->holidayEndDate_.c_str());
        if(to->holidayEndDate == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->holidayEndDate = c_stringNew_s(base, from->holidayEndDate_.c_str());
            if(to->holidayEndDate == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->automaticHolidayFromAwayActivation_days = (c_long)from->automaticHolidayFromAwayActivation_days_;
    to->automaticAwayFromHolidayActivation_days = (c_long)from->automaticAwayFromHolidayActivation_days_;
    to->automaticAwayActivation_hours = (c_long)from->automaticAwayActivation_hours_;
    to->preheatingTime = (c_double)from->preheatingTime_;
#ifdef OSPL_BOUNDS_CHECK
    if((((c_long)from->notificationSettingDay_) >= 0) && (((c_long)from->notificationSettingDay_) < 3) ){
        to->notificationSettingDay = (enum _Mind_NotificationSetting)from->notificationSettingDay_;
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'Mind::House.notificationSettingDay' of type 'NotificationSetting' is out of range.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->notificationSettingDay = (enum _Mind_NotificationSetting)from->notificationSettingDay_;
#endif
#ifdef OSPL_BOUNDS_CHECK
    if((((c_long)from->notificationSettingNight_) >= 0) && (((c_long)from->notificationSettingNight_) < 3) ){
        to->notificationSettingNight = (enum _Mind_NotificationSetting)from->notificationSettingNight_;
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'Mind::House.notificationSettingNight' of type 'NotificationSetting' is out of range.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->notificationSettingNight = (enum _Mind_NotificationSetting)from->notificationSettingNight_;
#endif
#ifdef OSPL_BOUNDS_CHECK
    if((((c_long)from->notificationSettingAway_) >= 0) && (((c_long)from->notificationSettingAway_) < 3) ){
        to->notificationSettingAway = (enum _Mind_NotificationSetting)from->notificationSettingAway_;
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'Mind::House.notificationSettingAway' of type 'NotificationSetting' is out of range.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->notificationSettingAway = (enum _Mind_NotificationSetting)from->notificationSettingAway_;
#endif
#ifdef OSPL_BOUNDS_CHECK
    if((((c_long)from->notificationSettingHoliday_) >= 0) && (((c_long)from->notificationSettingHoliday_) < 3) ){
        to->notificationSettingHoliday = (enum _Mind_NotificationSetting)from->notificationSettingHoliday_;
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'Mind::House.notificationSettingHoliday' of type 'NotificationSetting' is out of range.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->notificationSettingHoliday = (enum _Mind_NotificationSetting)from->notificationSettingHoliday_;
#endif
#ifdef OSPL_BOUNDS_CHECK
    if((((c_long)from->notificationSettingGuest_) >= 0) && (((c_long)from->notificationSettingGuest_) < 3) ){
        to->notificationSettingGuest = (enum _Mind_NotificationSetting)from->notificationSettingGuest_;
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'Mind::House.notificationSettingGuest' of type 'NotificationSetting' is out of range.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->notificationSettingGuest = (enum _Mind_NotificationSetting)from->notificationSettingGuest_;
#endif
#ifdef OSPL_BOUNDS_CHECK
    if((((c_long)from->alarmSetting_) >= 0) && (((c_long)from->alarmSetting_) < 4) ){
        to->alarmSetting = (enum _Mind_NightAlarmSetting)from->alarmSetting_;
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'Mind::House.alarmSetting' of type 'NightAlarmSetting' is out of range.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->alarmSetting = (enum _Mind_NightAlarmSetting)from->alarmSetting_;
#endif
    to->geofenceThreshold = (c_double)from->geofenceThreshold_;
    to->streamingEnabled = (c_bool)from->streamingEnabled_;
    to->livenessSimulation = (c_bool)from->livenessSimulation_;
    to->guestCheckoutTimeout = (c_long)from->guestCheckoutTimeout_;
    to->checkoutTimeout = (c_long)from->checkoutTimeout_;
    to->checkinTimeout = (c_long)from->checkinTimeout_;
#ifdef OSPL_BOUNDS_CHECK
        to->longitude = c_stringNew_s(base, from->longitude_.c_str());
        if(to->longitude == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->longitude = c_stringNew_s(base, from->longitude_.c_str());
            if(to->longitude == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->latitudine = c_stringNew_s(base, from->latitudine_.c_str());
        if(to->latitudine == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->latitudine = c_stringNew_s(base, from->latitudine_.c_str());
            if(to->latitudine == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->alarmDuration = (c_long)from->alarmDuration_;
    to->alarmMaxRepeat = (c_long)from->alarmMaxRepeat_;
    to->coThreshold = (c_double)from->coThreshold_;
    to->coTolerance = (c_double)from->coTolerance_;
    to->humidityThreshold = (c_double)from->humidityThreshold_;
    to->humidityTolerance = (c_double)from->humidityTolerance_;
    to->vocThreshold = (c_double)from->vocThreshold_;
    to->vocTolerance = (c_double)from->vocTolerance_;
    to->co2Threshold = (c_double)from->co2Threshold_;
    to->co2Tolerance = (c_double)from->co2Tolerance_;
    to->nh4Threshold = (c_double)from->nh4Threshold_;
    to->nh4Tolerance = (c_double)from->nh4Tolerance_;
    to->motionThreshold = (c_double)from->motionThreshold_;
    to->motionTolerance = (c_double)from->motionTolerance_;
    to->brightnessThreshold = (c_double)from->brightnessThreshold_;
    to->brightnessTolerance = (c_double)from->brightnessTolerance_;
    to->cloudyThreshold = (c_double)from->cloudyThreshold_;
    to->cloudyTolerance = (c_double)from->cloudyTolerance_;
#ifdef OSPL_BOUNDS_CHECK
        to->lowerDayThreshold = c_stringNew_s(base, from->lowerDayThreshold_.c_str());
        if(to->lowerDayThreshold == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->lowerDayThreshold = c_stringNew_s(base, from->lowerDayThreshold_.c_str());
            if(to->lowerDayThreshold == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->upperDayThreshold = c_stringNew_s(base, from->upperDayThreshold_.c_str());
        if(to->upperDayThreshold == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->upperDayThreshold = c_stringNew_s(base, from->upperDayThreshold_.c_str());
            if(to->upperDayThreshold == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_House_Network_Settings__copyIn(
    c_base base,
    const class ::Mind::House_Network_Settings *from,
    struct _Mind_House_Network_Settings *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        c_string *dest0;
        const ::Mind::House_Network_Settings::_MACAddresses_seq *src = &from->MACAddresses_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "c_string"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<c_string>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (c_string *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
#ifdef OSPL_BOUNDS_CHECK
                if((*src)[i0]){
                    dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                    if(dest0[i0] == NULL) {
                        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                    }
                } else {
                    OS_REPORT (OS_ERROR, "copyIn", 0,"Element of 'Mind::House_Network_Settings.*src' of type 'c_string' is NULL.");
                    result = V_COPYIN_RESULT_INVALID;
                }
#else
                dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                if(dest0[i0] == NULL) {
                    result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                }
#endif
            }
            to->MACAddresses = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (c_string *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
#ifdef OSPL_BOUNDS_CHECK
                if((*src)[i0]){
                    dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                    if(dest0[i0] == NULL) {
                        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                    }
                } else {
                    OS_REPORT (OS_ERROR, "copyIn", 0,"Element of 'Mind::House_Network_Settings.*src' of type 'c_string' is NULL.");
                    result = V_COPYIN_RESULT_INVALID;
                }
#else
                dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                if(dest0[i0] == NULL) {
                    result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                }
#endif
            }
            to->MACAddresses = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        c_string *dest0;
        const ::Mind::House_Network_Settings::_IPAddresses_seq *src = &from->IPAddresses_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "c_string"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<c_string>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (c_string *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
#ifdef OSPL_BOUNDS_CHECK
                if((*src)[i0]){
                    dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                    if(dest0[i0] == NULL) {
                        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                    }
                } else {
                    OS_REPORT (OS_ERROR, "copyIn", 0,"Element of 'Mind::House_Network_Settings.*src' of type 'c_string' is NULL.");
                    result = V_COPYIN_RESULT_INVALID;
                }
#else
                dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                if(dest0[i0] == NULL) {
                    result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                }
#endif
            }
            to->IPAddresses = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (c_string *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
#ifdef OSPL_BOUNDS_CHECK
                if((*src)[i0]){
                    dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                    if(dest0[i0] == NULL) {
                        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                    }
                } else {
                    OS_REPORT (OS_ERROR, "copyIn", 0,"Element of 'Mind::House_Network_Settings.*src' of type 'c_string' is NULL.");
                    result = V_COPYIN_RESULT_INVALID;
                }
#else
                dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                if(dest0[i0] == NULL) {
                    result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                }
#endif
            }
            to->IPAddresses = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        c_string *dest0;
        const ::Mind::House_Network_Settings::_serialNumber_seq *src = &from->serialNumber_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "c_string"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<c_string>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (c_string *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
#ifdef OSPL_BOUNDS_CHECK
                if((*src)[i0]){
                    dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                    if(dest0[i0] == NULL) {
                        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                    }
                } else {
                    OS_REPORT (OS_ERROR, "copyIn", 0,"Element of 'Mind::House_Network_Settings.*src' of type 'c_string' is NULL.");
                    result = V_COPYIN_RESULT_INVALID;
                }
#else
                dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                if(dest0[i0] == NULL) {
                    result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                }
#endif
            }
            to->serialNumber = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (c_string *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
#ifdef OSPL_BOUNDS_CHECK
                if((*src)[i0]){
                    dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                    if(dest0[i0] == NULL) {
                        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                    }
                } else {
                    OS_REPORT (OS_ERROR, "copyIn", 0,"Element of 'Mind::House_Network_Settings.*src' of type 'c_string' is NULL.");
                    result = V_COPYIN_RESULT_INVALID;
                }
#else
                dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                if(dest0[i0] == NULL) {
                    result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                }
#endif
            }
            to->serialNumber = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
#ifdef OSPL_BOUNDS_CHECK
        to->SSIDWifiUser = c_stringNew_s(base, from->SSIDWifiUser_.c_str());
        if(to->SSIDWifiUser == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->SSIDWifiUser = c_stringNew_s(base, from->SSIDWifiUser_.c_str());
            if(to->SSIDWifiUser == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->SSDIWifiPassw = c_stringNew_s(base, from->SSDIWifiPassw_.c_str());
        if(to->SSDIWifiPassw == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->SSDIWifiPassw = c_stringNew_s(base, from->SSDIWifiPassw_.c_str());
            if(to->SSDIWifiPassw == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_House_PeopleCount__copyIn(
    c_base base,
    const class ::Mind::House_PeopleCount *from,
    struct _Mind_House_PeopleCount *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

    to->knownPeopleCount = (c_long)from->knownPeopleCount_;
    to->previousKnownPeopleCount = (c_long)from->previousKnownPeopleCount_;
    to->unknownPeopleCount = (c_long)from->unknownPeopleCount_;
    to->previousUnknownPeopleCount = (c_long)from->previousUnknownPeopleCount_;
    to->bonusPeopleCount = (c_long)from->bonusPeopleCount_;
    to->previousBonusPeopleCount = (c_long)from->previousBonusPeopleCount_;
    to->peopleCount = (c_long)from->peopleCount_;
    to->previousPeopleCount = (c_long)from->previousPeopleCount_;
    return result;
}

v_copyin_result
__Mind_House_Occupancy__copyIn(
    c_base base,
    const class ::Mind::House_Occupancy *from,
    struct _Mind_House_Occupancy *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        c_double *dest0;
        const ::Mind::House_Occupancy::_weekDaily_seq *src = &from->weekDaily_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "c_double"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<c_double>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (c_double *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const c_double *buf0;
                buf0 = reinterpret_cast<const c_double *>(&((*src)[0]));
                memcpy (dest0,buf0,length0* sizeof(*dest0));
            }
            to->weekDaily = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (c_double *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const c_double *buf0;
                buf0 = reinterpret_cast<const c_double *>(&((*src)[0]));
                memcpy (dest0,buf0,length0* sizeof(*dest0));
            }
            to->weekDaily = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->weekDailySampleCount = (c_long)from->weekDailySampleCount_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        c_double *dest0;
        const ::Mind::House_Occupancy::_monthly_seq *src = &from->monthly_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "c_double"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<c_double>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (c_double *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const c_double *buf0;
                buf0 = reinterpret_cast<const c_double *>(&((*src)[0]));
                memcpy (dest0,buf0,length0* sizeof(*dest0));
            }
            to->monthly = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (c_double *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const c_double *buf0;
                buf0 = reinterpret_cast<const c_double *>(&((*src)[0]));
                memcpy (dest0,buf0,length0* sizeof(*dest0));
            }
            to->monthly = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->monthlySampleCount = (c_long)from->monthlySampleCount_;
    return result;
}

v_copyin_result
__Mind_House_Presence__copyIn(
    c_base base,
    const class ::Mind::House_Presence *from,
    struct _Mind_House_Presence *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->faceRecognized = (c_double)from->faceRecognized_;
    to->bluetoothRecognized = (c_double)from->bluetoothRecognized_;
    return result;
}

v_copyin_result
__Mind_House_PIN__copyIn(
    c_base base,
    const class ::Mind::House_PIN *from,
    struct _Mind_House_PIN *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->userPINCode = c_stringNew_s(base, from->userPINCode_.c_str());
        if(to->userPINCode == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->userPINCode = c_stringNew_s(base, from->userPINCode_.c_str());
            if(to->userPINCode == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_House_Command__copyIn(
    c_base base,
    const class ::Mind::House_Command *from,
    struct _Mind_House_Command *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->property = c_stringNew_s(base, from->property_.c_str());
        if(to->property == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->property = c_stringNew_s(base, from->property_.c_str());
            if(to->property == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->value = c_stringNew_s(base, from->value_.c_str());
        if(to->value == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->value = c_stringNew_s(base, from->value_.c_str());
            if(to->value == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_House_Signal__copyIn(
    c_base base,
    const class ::Mind::House_Signal *from,
    struct _Mind_House_Signal *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->name = c_stringNew_s(base, from->name_.c_str());
        if(to->name == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->name = c_stringNew_s(base, from->name_.c_str());
            if(to->name == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->value = c_stringNew_s(base, from->value_.c_str());
        if(to->value == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->value = c_stringNew_s(base, from->value_.c_str());
            if(to->value == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->ttl = (c_double)from->ttl_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Firmware__copyIn(
    c_base base,
    const class ::Mind::Firmware *from,
    struct _Mind_Firmware *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        c_octet *dest0;
        const ::Mind::Firmware::_fwMicro_seq *src = &from->fwMicro_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "c_octet"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<c_octet>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (c_octet *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const c_octet *buf0;
                buf0 = reinterpret_cast<const c_octet *>(&((*src)[0]));
                memcpy (dest0,buf0,length0* sizeof(*dest0));
            }
            to->fwMicro = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (c_octet *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const c_octet *buf0;
                buf0 = reinterpret_cast<const c_octet *>(&((*src)[0]));
                memcpy (dest0,buf0,length0* sizeof(*dest0));
            }
            to->fwMicro = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        c_octet *dest0;
        const ::Mind::Firmware::_fwESP8266_seq *src = &from->fwESP8266_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "c_octet"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<c_octet>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (c_octet *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const c_octet *buf0;
                buf0 = reinterpret_cast<const c_octet *>(&((*src)[0]));
                memcpy (dest0,buf0,length0* sizeof(*dest0));
            }
            to->fwESP8266 = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (c_octet *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const c_octet *buf0;
                buf0 = reinterpret_cast<const c_octet *>(&((*src)[0]));
                memcpy (dest0,buf0,length0* sizeof(*dest0));
            }
            to->fwESP8266 = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    return result;
}

void
__Mind_House__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_House *from = (const struct _Mind_House *)_from;
    class ::Mind::House *to = (class ::Mind::House *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->name(from->name ? from->name : "");
    to->targetTemperatureAwaySummer((double)from->targetTemperatureAwaySummer);
    to->targetTemperatureHolidaySummer((double)from->targetTemperatureHolidaySummer);
    to->targetTemperatureAwayWinter((double)from->targetTemperatureAwayWinter);
    to->targetTemperatureHolidayWinter((double)from->targetTemperatureHolidayWinter);
    to->temperatureMode((::Mind::TemperatureMode)from->temperatureMode);
    to->automaticWinterSummerSwitch((bool)from->automaticWinterSummerSwitch);
    to->lowTemperatureThreshold((double)from->lowTemperatureThreshold);
    to->highTemperatureThreshold((double)from->highTemperatureThreshold);
    to->currentMode((::Mind::HouseMode)from->currentMode);
    to->currentState((::Mind::StateName)from->currentState);
    {
        long size0;
        const c_octet *src0 = (const c_octet *)from->image;
        std::vector< uint8_t > *dst = &to->image();

        size0 = c_arraySize(c_sequence(from->image));
        to->image().clear();
        to->image().reserve(size0);
            (*dst).assign(src0, src0 + size0);
    }
    to->holidayStartDate(from->holidayStartDate ? from->holidayStartDate : "");
    to->holidayEndDate(from->holidayEndDate ? from->holidayEndDate : "");
    to->automaticHolidayFromAwayActivation_days((int32_t)from->automaticHolidayFromAwayActivation_days);
    to->automaticAwayFromHolidayActivation_days((int32_t)from->automaticAwayFromHolidayActivation_days);
    to->automaticAwayActivation_hours((int32_t)from->automaticAwayActivation_hours);
    to->preheatingTime((double)from->preheatingTime);
    to->notificationSettingDay((::Mind::NotificationSetting)from->notificationSettingDay);
    to->notificationSettingNight((::Mind::NotificationSetting)from->notificationSettingNight);
    to->notificationSettingAway((::Mind::NotificationSetting)from->notificationSettingAway);
    to->notificationSettingHoliday((::Mind::NotificationSetting)from->notificationSettingHoliday);
    to->notificationSettingGuest((::Mind::NotificationSetting)from->notificationSettingGuest);
    to->alarmSetting((::Mind::NightAlarmSetting)from->alarmSetting);
    to->geofenceThreshold((double)from->geofenceThreshold);
    to->streamingEnabled((bool)from->streamingEnabled);
    to->livenessSimulation((bool)from->livenessSimulation);
    to->guestCheckoutTimeout((int32_t)from->guestCheckoutTimeout);
    to->checkoutTimeout((int32_t)from->checkoutTimeout);
    to->checkinTimeout((int32_t)from->checkinTimeout);
    to->longitude(from->longitude ? from->longitude : "");
    to->latitudine(from->latitudine ? from->latitudine : "");
    to->alarmDuration((int32_t)from->alarmDuration);
    to->alarmMaxRepeat((int32_t)from->alarmMaxRepeat);
    to->coThreshold((double)from->coThreshold);
    to->coTolerance((double)from->coTolerance);
    to->humidityThreshold((double)from->humidityThreshold);
    to->humidityTolerance((double)from->humidityTolerance);
    to->vocThreshold((double)from->vocThreshold);
    to->vocTolerance((double)from->vocTolerance);
    to->co2Threshold((double)from->co2Threshold);
    to->co2Tolerance((double)from->co2Tolerance);
    to->nh4Threshold((double)from->nh4Threshold);
    to->nh4Tolerance((double)from->nh4Tolerance);
    to->motionThreshold((double)from->motionThreshold);
    to->motionTolerance((double)from->motionTolerance);
    to->brightnessThreshold((double)from->brightnessThreshold);
    to->brightnessTolerance((double)from->brightnessTolerance);
    to->cloudyThreshold((double)from->cloudyThreshold);
    to->cloudyTolerance((double)from->cloudyTolerance);
    to->lowerDayThreshold(from->lowerDayThreshold ? from->lowerDayThreshold : "");
    to->upperDayThreshold(from->upperDayThreshold ? from->upperDayThreshold : "");
}

void
__Mind_House_Network_Settings__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_House_Network_Settings *from = (const struct _Mind_House_Network_Settings *)_from;
    class ::Mind::House_Network_Settings *to = (class ::Mind::House_Network_Settings *)_to;
    {
        long size0;
        const c_string *src0 = (const c_string *)from->MACAddresses;
        std::vector< std::string > *dst = &to->MACAddresses();

        size0 = c_arraySize(c_sequence(from->MACAddresses));
        to->MACAddresses().clear();
        to->MACAddresses().reserve(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst).push_back(src0[i0] ? src0[i0] : "");
            }
        }
    }
    {
        long size0;
        const c_string *src0 = (const c_string *)from->IPAddresses;
        std::vector< std::string > *dst = &to->IPAddresses();

        size0 = c_arraySize(c_sequence(from->IPAddresses));
        to->IPAddresses().clear();
        to->IPAddresses().reserve(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst).push_back(src0[i0] ? src0[i0] : "");
            }
        }
    }
    {
        long size0;
        const c_string *src0 = (const c_string *)from->serialNumber;
        std::vector< std::string > *dst = &to->serialNumber();

        size0 = c_arraySize(c_sequence(from->serialNumber));
        to->serialNumber().clear();
        to->serialNumber().reserve(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst).push_back(src0[i0] ? src0[i0] : "");
            }
        }
    }
    to->SSIDWifiUser(from->SSIDWifiUser ? from->SSIDWifiUser : "");
    to->SSDIWifiPassw(from->SSDIWifiPassw ? from->SSDIWifiPassw : "");
}

void
__Mind_House_PeopleCount__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_House_PeopleCount *from = (const struct _Mind_House_PeopleCount *)_from;
    class ::Mind::House_PeopleCount *to = (class ::Mind::House_PeopleCount *)_to;
    to->knownPeopleCount((int32_t)from->knownPeopleCount);
    to->previousKnownPeopleCount((int32_t)from->previousKnownPeopleCount);
    to->unknownPeopleCount((int32_t)from->unknownPeopleCount);
    to->previousUnknownPeopleCount((int32_t)from->previousUnknownPeopleCount);
    to->bonusPeopleCount((int32_t)from->bonusPeopleCount);
    to->previousBonusPeopleCount((int32_t)from->previousBonusPeopleCount);
    to->peopleCount((int32_t)from->peopleCount);
    to->previousPeopleCount((int32_t)from->previousPeopleCount);
}

void
__Mind_House_Occupancy__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_House_Occupancy *from = (const struct _Mind_House_Occupancy *)_from;
    class ::Mind::House_Occupancy *to = (class ::Mind::House_Occupancy *)_to;
    {
        long size0;
        const c_double *src0 = (const c_double *)from->weekDaily;
        std::vector< double > *dst = &to->weekDaily();

        size0 = c_arraySize(c_sequence(from->weekDaily));
        to->weekDaily().clear();
        to->weekDaily().reserve(size0);
            (*dst).assign(src0, src0 + size0);
    }
    to->weekDailySampleCount((int32_t)from->weekDailySampleCount);
    {
        long size0;
        const c_double *src0 = (const c_double *)from->monthly;
        std::vector< double > *dst = &to->monthly();

        size0 = c_arraySize(c_sequence(from->monthly));
        to->monthly().clear();
        to->monthly().reserve(size0);
            (*dst).assign(src0, src0 + size0);
    }
    to->monthlySampleCount((int32_t)from->monthlySampleCount);
}

void
__Mind_House_Presence__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_House_Presence *from = (const struct _Mind_House_Presence *)_from;
    class ::Mind::House_Presence *to = (class ::Mind::House_Presence *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->faceRecognized((double)from->faceRecognized);
    to->bluetoothRecognized((double)from->bluetoothRecognized);
}

void
__Mind_House_PIN__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_House_PIN *from = (const struct _Mind_House_PIN *)_from;
    class ::Mind::House_PIN *to = (class ::Mind::House_PIN *)_to;
    to->userPINCode(from->userPINCode ? from->userPINCode : "");
}

void
__Mind_House_Command__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_House_Command *from = (const struct _Mind_House_Command *)_from;
    class ::Mind::House_Command *to = (class ::Mind::House_Command *)_to;
    to->property(from->property ? from->property : "");
    to->value(from->value ? from->value : "");
}

void
__Mind_House_Signal__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_House_Signal *from = (const struct _Mind_House_Signal *)_from;
    class ::Mind::House_Signal *to = (class ::Mind::House_Signal *)_to;
    to->name(from->name ? from->name : "");
    to->value(from->value ? from->value : "");
    to->ttl((double)from->ttl);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_Firmware__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Firmware *from = (const struct _Mind_Firmware *)_from;
    class ::Mind::Firmware *to = (class ::Mind::Firmware *)_to;
    {
        long size0;
        const c_octet *src0 = (const c_octet *)from->fwMicro;
        std::vector< uint8_t > *dst = &to->fwMicro();

        size0 = c_arraySize(c_sequence(from->fwMicro));
        to->fwMicro().clear();
        to->fwMicro().reserve(size0);
            (*dst).assign(src0, src0 + size0);
    }
    {
        long size0;
        const c_octet *src0 = (const c_octet *)from->fwESP8266;
        std::vector< uint8_t > *dst = &to->fwESP8266();

        size0 = c_arraySize(c_sequence(from->fwESP8266));
        to->fwESP8266().clear();
        to->fwESP8266().reserve(size0);
            (*dst).assign(src0, src0 + size0);
    }
}

