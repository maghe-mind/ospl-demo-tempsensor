#include "NotificationService_DCPS.hpp"

#include <v_copyIn.h>
#include <v_topic.h>
#include <os_stdlib.h>
#include <string.h>
#include <os_report.h>

v_copyin_result
__Mind_Notification__copyIn(
    c_base base,
    const class ::Mind::Notification *from,
    struct _Mind_Notification *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
    if((((c_long)from->type_) >= 0) && (((c_long)from->type_) < 3) ){
        to->type = (enum _Mind_NotificationType)from->type_;
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'Mind::Notification.type' of type 'NotificationType' is out of range.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->type = (enum _Mind_NotificationType)from->type_;
#endif
#ifdef OSPL_BOUNDS_CHECK
    if((((c_long)from->subType_) >= 0) && (((c_long)from->subType_) < 18) ){
        to->subType = (enum _Mind_NotificationSubtype)from->subType_;
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'Mind::Notification.subType' of type 'NotificationSubtype' is out of range.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->subType = (enum _Mind_NotificationSubtype)from->subType_;
#endif
    to->timestamp = (c_long)from->timestamp_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->URL = c_stringNew_s(base, from->URL_.c_str());
        if(to->URL == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->URL = c_stringNew_s(base, from->URL_.c_str());
            if(to->URL == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->read = (c_bool)from->read_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_NotificationResponseType *dest0;
        const ::Mind::Notification::_responses_seq *src = &from->responses_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::NotificationResponseType"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::NotificationResponseType>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_NotificationResponseType *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_NotificationResponseType *buf0;
                buf0 = reinterpret_cast<const enum _Mind_NotificationResponseType *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->responses = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_NotificationResponseType *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_NotificationResponseType *buf0;
                buf0 = reinterpret_cast<const enum _Mind_NotificationResponseType *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->responses = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    return result;
}

v_copyin_result
__Mind_NotificationResponse__copyIn(
    c_base base,
    const class ::Mind::NotificationResponse *from,
    struct _Mind_NotificationResponse *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDNotification = c_stringNew_s(base, from->UUIDNotification_.c_str());
        if(to->UUIDNotification == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDNotification = c_stringNew_s(base, from->UUIDNotification_.c_str());
            if(to->UUIDNotification == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
    if((((c_long)from->response_) >= 0) && (((c_long)from->response_) < 3) ){
        to->response = (enum _Mind_NotificationResponseType)from->response_;
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'Mind::NotificationResponse.response' of type 'NotificationResponseType' is out of range.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->response = (enum _Mind_NotificationResponseType)from->response_;
#endif
    return result;
}

v_copyin_result
__Mind_Reminder__copyIn(
    c_base base,
    const class ::Mind::Reminder *from,
    struct _Mind_Reminder *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->reminderDate = (c_long)from->reminderDate_;
#ifdef OSPL_BOUNDS_CHECK
        to->subject = c_stringNew_s(base, from->subject_.c_str());
        if(to->subject == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->subject = c_stringNew_s(base, from->subject_.c_str());
            if(to->subject == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->alertFrom = c_stringNew_s(base, from->alertFrom_.c_str());
        if(to->alertFrom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->alertFrom = c_stringNew_s(base, from->alertFrom_.c_str());
            if(to->alertFrom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->message = c_stringNew_s(base, from->message_.c_str());
        if(to->message == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->message = c_stringNew_s(base, from->message_.c_str());
            if(to->message == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->acknowledged = (c_bool)from->acknowledged_;
    return result;
}

v_copyin_result
__Mind_Reminder_Command__copyIn(
    c_base base,
    const class ::Mind::Reminder_Command *from,
    struct _Mind_Reminder_Command *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->property = c_stringNew_s(base, from->property_.c_str());
        if(to->property == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->property = c_stringNew_s(base, from->property_.c_str());
            if(to->property == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->value = c_stringNew_s(base, from->value_.c_str());
        if(to->value == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->value = c_stringNew_s(base, from->value_.c_str());
            if(to->value == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Timer__copyIn(
    c_base base,
    const class ::Mind::Timer *from,
    struct _Mind_Timer *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->timeStart = c_stringNew_s(base, from->timeStart_.c_str());
        if(to->timeStart == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->timeStart = c_stringNew_s(base, from->timeStart_.c_str());
            if(to->timeStart == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->timeInterval = (c_long)from->timeInterval_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Timer_Command__copyIn(
    c_base base,
    const class ::Mind::Timer_Command *from,
    struct _Mind_Timer_Command *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->property = c_stringNew_s(base, from->property_.c_str());
        if(to->property == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->property = c_stringNew_s(base, from->property_.c_str());
            if(to->property == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->value = c_stringNew_s(base, from->value_.c_str());
        if(to->value == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->value = c_stringNew_s(base, from->value_.c_str());
            if(to->value == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Wakeup__copyIn(
    c_base base,
    const class ::Mind::Wakeup *from,
    struct _Mind_Wakeup *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->dailyMask = c_stringNew_s(base, from->dailyMask_.c_str());
        if(to->dailyMask == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->dailyMask = c_stringNew_s(base, from->dailyMask_.c_str());
            if(to->dailyMask == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->time = c_stringNew_s(base, from->time_.c_str());
        if(to->time == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->time = c_stringNew_s(base, from->time_.c_str());
            if(to->time == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDUser = c_stringNew_s(base, from->UUIDUser_.c_str());
        if(to->UUIDUser == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDUser = c_stringNew_s(base, from->UUIDUser_.c_str());
            if(to->UUIDUser == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->soundType = c_stringNew_s(base, from->soundType_.c_str());
        if(to->soundType == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->soundType = c_stringNew_s(base, from->soundType_.c_str());
            if(to->soundType == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->enabled = (c_bool)from->enabled_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Wakeup_Command__copyIn(
    c_base base,
    const class ::Mind::Wakeup_Command *from,
    struct _Mind_Wakeup_Command *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->property = c_stringNew_s(base, from->property_.c_str());
        if(to->property == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->property = c_stringNew_s(base, from->property_.c_str());
            if(to->property == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->value = c_stringNew_s(base, from->value_.c_str());
        if(to->value == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->value = c_stringNew_s(base, from->value_.c_str());
            if(to->value == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

void
__Mind_Notification__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Notification *from = (const struct _Mind_Notification *)_from;
    class ::Mind::Notification *to = (class ::Mind::Notification *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->type((::Mind::NotificationType)from->type);
    to->subType((::Mind::NotificationSubtype)from->subType);
    to->timestamp((int32_t)from->timestamp);
    to->description(from->description ? from->description : "");
    to->URL(from->URL ? from->URL : "");
    to->read((bool)from->read);
    {
        long size0;
        const enum _Mind_NotificationResponseType *src0 = (const enum _Mind_NotificationResponseType *)from->responses;
        std::vector< ::Mind::NotificationResponseType > *dst = &to->responses();

        size0 = c_arraySize(c_sequence(from->responses));
        to->responses().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::NotificationResponseType)src0[i0];
            }
        }
    }
}

void
__Mind_NotificationResponse__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_NotificationResponse *from = (const struct _Mind_NotificationResponse *)_from;
    class ::Mind::NotificationResponse *to = (class ::Mind::NotificationResponse *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->UUIDNotification(from->UUIDNotification ? from->UUIDNotification : "");
    to->response((::Mind::NotificationResponseType)from->response);
}

void
__Mind_Reminder__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Reminder *from = (const struct _Mind_Reminder *)_from;
    class ::Mind::Reminder *to = (class ::Mind::Reminder *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->reminderDate((int32_t)from->reminderDate);
    to->subject(from->subject ? from->subject : "");
    to->alertFrom(from->alertFrom ? from->alertFrom : "");
    to->message(from->message ? from->message : "");
    to->acknowledged((bool)from->acknowledged);
}

void
__Mind_Reminder_Command__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Reminder_Command *from = (const struct _Mind_Reminder_Command *)_from;
    class ::Mind::Reminder_Command *to = (class ::Mind::Reminder_Command *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->property(from->property ? from->property : "");
    to->value(from->value ? from->value : "");
}

void
__Mind_Timer__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Timer *from = (const struct _Mind_Timer *)_from;
    class ::Mind::Timer *to = (class ::Mind::Timer *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->timeStart(from->timeStart ? from->timeStart : "");
    to->timeInterval((int32_t)from->timeInterval);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_Timer_Command__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Timer_Command *from = (const struct _Mind_Timer_Command *)_from;
    class ::Mind::Timer_Command *to = (class ::Mind::Timer_Command *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->property(from->property ? from->property : "");
    to->value(from->value ? from->value : "");
}

void
__Mind_Wakeup__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Wakeup *from = (const struct _Mind_Wakeup *)_from;
    class ::Mind::Wakeup *to = (class ::Mind::Wakeup *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->dailyMask(from->dailyMask ? from->dailyMask : "");
    to->time(from->time ? from->time : "");
    to->UUIDUser(from->UUIDUser ? from->UUIDUser : "");
    to->soundType(from->soundType ? from->soundType : "");
    to->enabled((bool)from->enabled);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_Wakeup_Command__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Wakeup_Command *from = (const struct _Mind_Wakeup_Command *)_from;
    class ::Mind::Wakeup_Command *to = (class ::Mind::Wakeup_Command *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->property(from->property ? from->property : "");
    to->value(from->value ? from->value : "");
}

