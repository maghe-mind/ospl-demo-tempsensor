#include "Configuration_DCPS.hpp"

#include <v_copyIn.h>
#include <v_topic.h>
#include <os_stdlib.h>
#include <string.h>
#include <os_report.h>

v_copyin_result
__Mind_VirtualItem__copyIn(
    c_base base,
    const class ::Mind::VirtualItem *from,
    struct _Mind_VirtualItem *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
    if((((c_long)from->category_) >= 0) && (((c_long)from->category_) < 121) ){
        to->category = (enum _Mind_Category)from->category_;
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'Mind::VirtualItem.category' of type 'Category' is out of range.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->category = (enum _Mind_Category)from->category_;
#endif
#ifdef OSPL_BOUNDS_CHECK
    if((((c_long)from->location_) >= 0) && (((c_long)from->location_) < 6) ){
        to->location = (enum _Mind_VirtualItemLocation)from->location_;
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'Mind::VirtualItem.location' of type 'VirtualItemLocation' is out of range.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->location = (enum _Mind_VirtualItemLocation)from->location_;
#endif
    to->GID = (c_long)from->GID_;
    to->priority = (c_long)from->priority_;
#ifdef OSPL_BOUNDS_CHECK
        to->value = c_stringNew_s(base, from->value_.c_str());
        if(to->value == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->value = c_stringNew_s(base, from->value_.c_str());
            if(to->value == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->enabled = (c_bool)from->enabled_;
    to->delay = (c_long)from->delay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        c_string *dest0;
        const ::Mind::VirtualItem::_triggers_seq *src = &from->triggers_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "c_string"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<c_string>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (c_string *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
#ifdef OSPL_BOUNDS_CHECK
                if((*src)[i0]){
                    dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                    if(dest0[i0] == NULL) {
                        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                    }
                } else {
                    OS_REPORT (OS_ERROR, "copyIn", 0,"Element of 'Mind::VirtualItem.*src' of type 'c_string' is NULL.");
                    result = V_COPYIN_RESULT_INVALID;
                }
#else
                dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                if(dest0[i0] == NULL) {
                    result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                }
#endif
            }
            to->triggers = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (c_string *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
#ifdef OSPL_BOUNDS_CHECK
                if((*src)[i0]){
                    dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                    if(dest0[i0] == NULL) {
                        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                    }
                } else {
                    OS_REPORT (OS_ERROR, "copyIn", 0,"Element of 'Mind::VirtualItem.*src' of type 'c_string' is NULL.");
                    result = V_COPYIN_RESULT_INVALID;
                }
#else
                dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                if(dest0[i0] == NULL) {
                    result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                }
#endif
            }
            to->triggers = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    return result;
}

v_copyin_result
__Mind_ConfiguredItem__copyIn(
    c_base base,
    const class ::Mind::ConfiguredItem *from,
    struct _Mind_ConfiguredItem *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUIDItem = c_stringNew_s(base, from->UUIDItem_.c_str());
        if(to->UUIDItem == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDItem = c_stringNew_s(base, from->UUIDItem_.c_str());
            if(to->UUIDItem == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
    if((((c_long)from->category_) >= 0) && (((c_long)from->category_) < 121) ){
        to->category = (enum _Mind_Category)from->category_;
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'Mind::ConfiguredItem.category' of type 'Category' is out of range.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->category = (enum _Mind_Category)from->category_;
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->value = c_stringNew_s(base, from->value_.c_str());
        if(to->value == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->value = c_stringNew_s(base, from->value_.c_str());
            if(to->value == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->delay = (c_long)from->delay_;
    return result;
}

v_copyin_result
__Mind_Configuration__copyIn(
    c_base base,
    const class ::Mind::Configuration *from,
    struct _Mind_Configuration *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->name = c_stringNew_s(base, from->name_.c_str());
        if(to->name == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->name = c_stringNew_s(base, from->name_.c_str());
            if(to->name == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
    if((((c_long)from->activeItemConfiguration_) >= 0) && (((c_long)from->activeItemConfiguration_) < 3) ){
        to->activeItemConfiguration = (enum _Mind_ConfigurationType)from->activeItemConfiguration_;
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'Mind::Configuration.activeItemConfiguration' of type 'ConfigurationType' is out of range.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->activeItemConfiguration = (enum _Mind_ConfigurationType)from->activeItemConfiguration_;
#endif
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        c_string *dest0;
        const ::Mind::Configuration::_configurationTriggers_seq *src = &from->configurationTriggers_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "c_string"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<c_string>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (c_string *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
#ifdef OSPL_BOUNDS_CHECK
                if((*src)[i0]){
                    dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                    if(dest0[i0] == NULL) {
                        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                    }
                } else {
                    OS_REPORT (OS_ERROR, "copyIn", 0,"Element of 'Mind::Configuration.*src' of type 'c_string' is NULL.");
                    result = V_COPYIN_RESULT_INVALID;
                }
#else
                dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                if(dest0[i0] == NULL) {
                    result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                }
#endif
            }
            to->configurationTriggers = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (c_string *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
#ifdef OSPL_BOUNDS_CHECK
                if((*src)[i0]){
                    dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                    if(dest0[i0] == NULL) {
                        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                    }
                } else {
                    OS_REPORT (OS_ERROR, "copyIn", 0,"Element of 'Mind::Configuration.*src' of type 'c_string' is NULL.");
                    result = V_COPYIN_RESULT_INVALID;
                }
#else
                dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                if(dest0[i0] == NULL) {
                    result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                }
#endif
            }
            to->configurationTriggers = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        struct _Mind_VirtualItem *dest0;
        const ::Mind::Configuration::_defaultVirtualItems_seq *src = &from->defaultVirtualItems_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::VirtualItem"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::VirtualItem>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (struct _Mind_VirtualItem *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
                extern v_copyin_result __Mind_VirtualItem__copyIn(c_base base,
                    const Mind::VirtualItem *From,
                    struct _Mind_VirtualItem *To);

                result = __Mind_VirtualItem__copyIn(base, &(*src)[i0], (struct _Mind_VirtualItem *)&dest0[i0]);
            }
            to->defaultVirtualItems = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (struct _Mind_VirtualItem *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
                extern v_copyin_result __Mind_VirtualItem__copyIn(c_base base,
                    const Mind::VirtualItem *From,
                    struct _Mind_VirtualItem *To);

                result = __Mind_VirtualItem__copyIn(base, &(*src)[i0], (struct _Mind_VirtualItem *)&dest0[i0]);
            }
            to->defaultVirtualItems = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        struct _Mind_VirtualItem *dest0;
        const ::Mind::Configuration::_preferredVirtualItems_seq *src = &from->preferredVirtualItems_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::VirtualItem"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::VirtualItem>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (struct _Mind_VirtualItem *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
                extern v_copyin_result __Mind_VirtualItem__copyIn(c_base base,
                    const Mind::VirtualItem *From,
                    struct _Mind_VirtualItem *To);

                result = __Mind_VirtualItem__copyIn(base, &(*src)[i0], (struct _Mind_VirtualItem *)&dest0[i0]);
            }
            to->preferredVirtualItems = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (struct _Mind_VirtualItem *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
                extern v_copyin_result __Mind_VirtualItem__copyIn(c_base base,
                    const Mind::VirtualItem *From,
                    struct _Mind_VirtualItem *To);

                result = __Mind_VirtualItem__copyIn(base, &(*src)[i0], (struct _Mind_VirtualItem *)&dest0[i0]);
            }
            to->preferredVirtualItems = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        struct _Mind_VirtualItem *dest0;
        const ::Mind::Configuration::_learnedVirtualItems_seq *src = &from->learnedVirtualItems_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::VirtualItem"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::VirtualItem>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (struct _Mind_VirtualItem *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
                extern v_copyin_result __Mind_VirtualItem__copyIn(c_base base,
                    const Mind::VirtualItem *From,
                    struct _Mind_VirtualItem *To);

                result = __Mind_VirtualItem__copyIn(base, &(*src)[i0], (struct _Mind_VirtualItem *)&dest0[i0]);
            }
            to->learnedVirtualItems = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (struct _Mind_VirtualItem *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
                extern v_copyin_result __Mind_VirtualItem__copyIn(c_base base,
                    const Mind::VirtualItem *From,
                    struct _Mind_VirtualItem *To);

                result = __Mind_VirtualItem__copyIn(base, &(*src)[i0], (struct _Mind_VirtualItem *)&dest0[i0]);
            }
            to->learnedVirtualItems = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        struct _Mind_ConfiguredItem *dest0;
        const ::Mind::Configuration::_defaultConfiguredItems_seq *src = &from->defaultConfiguredItems_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::ConfiguredItem"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::ConfiguredItem>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (struct _Mind_ConfiguredItem *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
                extern v_copyin_result __Mind_ConfiguredItem__copyIn(c_base base,
                    const Mind::ConfiguredItem *From,
                    struct _Mind_ConfiguredItem *To);

                result = __Mind_ConfiguredItem__copyIn(base, &(*src)[i0], (struct _Mind_ConfiguredItem *)&dest0[i0]);
            }
            to->defaultConfiguredItems = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (struct _Mind_ConfiguredItem *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
                extern v_copyin_result __Mind_ConfiguredItem__copyIn(c_base base,
                    const Mind::ConfiguredItem *From,
                    struct _Mind_ConfiguredItem *To);

                result = __Mind_ConfiguredItem__copyIn(base, &(*src)[i0], (struct _Mind_ConfiguredItem *)&dest0[i0]);
            }
            to->defaultConfiguredItems = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        struct _Mind_ConfiguredItem *dest0;
        const ::Mind::Configuration::_preferredConfiguredItems_seq *src = &from->preferredConfiguredItems_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::ConfiguredItem"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::ConfiguredItem>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (struct _Mind_ConfiguredItem *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
                extern v_copyin_result __Mind_ConfiguredItem__copyIn(c_base base,
                    const Mind::ConfiguredItem *From,
                    struct _Mind_ConfiguredItem *To);

                result = __Mind_ConfiguredItem__copyIn(base, &(*src)[i0], (struct _Mind_ConfiguredItem *)&dest0[i0]);
            }
            to->preferredConfiguredItems = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (struct _Mind_ConfiguredItem *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
                extern v_copyin_result __Mind_ConfiguredItem__copyIn(c_base base,
                    const Mind::ConfiguredItem *From,
                    struct _Mind_ConfiguredItem *To);

                result = __Mind_ConfiguredItem__copyIn(base, &(*src)[i0], (struct _Mind_ConfiguredItem *)&dest0[i0]);
            }
            to->preferredConfiguredItems = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        struct _Mind_ConfiguredItem *dest0;
        const ::Mind::Configuration::_learnedConfiguredItems_seq *src = &from->learnedConfiguredItems_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::ConfiguredItem"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::ConfiguredItem>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (struct _Mind_ConfiguredItem *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
                extern v_copyin_result __Mind_ConfiguredItem__copyIn(c_base base,
                    const Mind::ConfiguredItem *From,
                    struct _Mind_ConfiguredItem *To);

                result = __Mind_ConfiguredItem__copyIn(base, &(*src)[i0], (struct _Mind_ConfiguredItem *)&dest0[i0]);
            }
            to->learnedConfiguredItems = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (struct _Mind_ConfiguredItem *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
                extern v_copyin_result __Mind_ConfiguredItem__copyIn(c_base base,
                    const Mind::ConfiguredItem *From,
                    struct _Mind_ConfiguredItem *To);

                result = __Mind_ConfiguredItem__copyIn(base, &(*src)[i0], (struct _Mind_ConfiguredItem *)&dest0[i0]);
            }
            to->learnedConfiguredItems = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    return result;
}

v_copyin_result
__Mind_Configuration_Command_Set_Active_Item_Configuration__copyIn(
    c_base base,
    const class ::Mind::Configuration_Command_Set_Active_Item_Configuration *from,
    struct _Mind_Configuration_Command_Set_Active_Item_Configuration *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
    if((((c_long)from->activeItemConfiguration_) >= 0) && (((c_long)from->activeItemConfiguration_) < 3) ){
        to->activeItemConfiguration = (enum _Mind_ConfigurationType)from->activeItemConfiguration_;
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'Mind::Configuration_Command_Set_Active_Item_Configuration.activeItemConfiguration' of type 'ConfigurationType' is out of range.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->activeItemConfiguration = (enum _Mind_ConfigurationType)from->activeItemConfiguration_;
#endif
    return result;
}

v_copyin_result
__Mind_Configuration_Command_Set_Preferred_Virtual_Items_Configuration__copyIn(
    c_base base,
    const class ::Mind::Configuration_Command_Set_Preferred_Virtual_Items_Configuration *from,
    struct _Mind_Configuration_Command_Set_Preferred_Virtual_Items_Configuration *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        struct _Mind_VirtualItem *dest0;
        const ::Mind::Configuration_Command_Set_Preferred_Virtual_Items_Configuration::_preferredVirtualItems_seq *src = &from->preferredVirtualItems_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::VirtualItem"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::VirtualItem>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (struct _Mind_VirtualItem *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
                extern v_copyin_result __Mind_VirtualItem__copyIn(c_base base,
                    const Mind::VirtualItem *From,
                    struct _Mind_VirtualItem *To);

                result = __Mind_VirtualItem__copyIn(base, &(*src)[i0], (struct _Mind_VirtualItem *)&dest0[i0]);
            }
            to->preferredVirtualItems = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (struct _Mind_VirtualItem *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
                extern v_copyin_result __Mind_VirtualItem__copyIn(c_base base,
                    const Mind::VirtualItem *From,
                    struct _Mind_VirtualItem *To);

                result = __Mind_VirtualItem__copyIn(base, &(*src)[i0], (struct _Mind_VirtualItem *)&dest0[i0]);
            }
            to->preferredVirtualItems = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    return result;
}

v_copyin_result
__Mind_Configuration_Command_Set_Preferred_Configured_Items_Configuration__copyIn(
    c_base base,
    const class ::Mind::Configuration_Command_Set_Preferred_Configured_Items_Configuration *from,
    struct _Mind_Configuration_Command_Set_Preferred_Configured_Items_Configuration *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        struct _Mind_ConfiguredItem *dest0;
        const ::Mind::Configuration_Command_Set_Preferred_Configured_Items_Configuration::_preferredConfiguredItems_seq *src = &from->preferredConfiguredItems_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::ConfiguredItem"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::ConfiguredItem>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (struct _Mind_ConfiguredItem *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
                extern v_copyin_result __Mind_ConfiguredItem__copyIn(c_base base,
                    const Mind::ConfiguredItem *From,
                    struct _Mind_ConfiguredItem *To);

                result = __Mind_ConfiguredItem__copyIn(base, &(*src)[i0], (struct _Mind_ConfiguredItem *)&dest0[i0]);
            }
            to->preferredConfiguredItems = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (struct _Mind_ConfiguredItem *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
                extern v_copyin_result __Mind_ConfiguredItem__copyIn(c_base base,
                    const Mind::ConfiguredItem *From,
                    struct _Mind_ConfiguredItem *To);

                result = __Mind_ConfiguredItem__copyIn(base, &(*src)[i0], (struct _Mind_ConfiguredItem *)&dest0[i0]);
            }
            to->preferredConfiguredItems = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    return result;
}

void
__Mind_VirtualItem__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_VirtualItem *from = (const struct _Mind_VirtualItem *)_from;
    class ::Mind::VirtualItem *to = (class ::Mind::VirtualItem *)_to;
    to->category((::Mind::Category)from->category);
    to->location((::Mind::VirtualItemLocation)from->location);
    to->GID((int32_t)from->GID);
    to->priority((int32_t)from->priority);
    to->value(from->value ? from->value : "");
    to->enabled((bool)from->enabled);
    to->delay((int32_t)from->delay);
    {
        long size0;
        const c_string *src0 = (const c_string *)from->triggers;
        std::vector< std::string > *dst = &to->triggers();

        size0 = c_arraySize(c_sequence(from->triggers));
        to->triggers().clear();
        to->triggers().reserve(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst).push_back(src0[i0] ? src0[i0] : "");
            }
        }
    }
}

void
__Mind_ConfiguredItem__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_ConfiguredItem *from = (const struct _Mind_ConfiguredItem *)_from;
    class ::Mind::ConfiguredItem *to = (class ::Mind::ConfiguredItem *)_to;
    to->UUIDItem(from->UUIDItem ? from->UUIDItem : "");
    to->category((::Mind::Category)from->category);
    to->value(from->value ? from->value : "");
    to->delay((int32_t)from->delay);
}

void
__Mind_Configuration__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Configuration *from = (const struct _Mind_Configuration *)_from;
    class ::Mind::Configuration *to = (class ::Mind::Configuration *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
    to->name(from->name ? from->name : "");
    to->activeItemConfiguration((::Mind::ConfigurationType)from->activeItemConfiguration);
    {
        long size0;
        const c_string *src0 = (const c_string *)from->configurationTriggers;
        std::vector< std::string > *dst = &to->configurationTriggers();

        size0 = c_arraySize(c_sequence(from->configurationTriggers));
        to->configurationTriggers().clear();
        to->configurationTriggers().reserve(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst).push_back(src0[i0] ? src0[i0] : "");
            }
        }
    }
    {
        long size0;
        const struct _Mind_VirtualItem *src0 = (const struct _Mind_VirtualItem *)from->defaultVirtualItems;
        std::vector< ::Mind::VirtualItem > *dst = &to->defaultVirtualItems();

        size0 = c_arraySize(c_sequence(from->defaultVirtualItems));
        to->defaultVirtualItems().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
        extern void __Mind_VirtualItem__copyOut(const void *from, void *to);
                __Mind_VirtualItem__copyOut((const void *)&src0[i0], (void *)&(*dst)[i0]);
            }
        }
    }
    {
        long size0;
        const struct _Mind_VirtualItem *src0 = (const struct _Mind_VirtualItem *)from->preferredVirtualItems;
        std::vector< ::Mind::VirtualItem > *dst = &to->preferredVirtualItems();

        size0 = c_arraySize(c_sequence(from->preferredVirtualItems));
        to->preferredVirtualItems().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
        extern void __Mind_VirtualItem__copyOut(const void *from, void *to);
                __Mind_VirtualItem__copyOut((const void *)&src0[i0], (void *)&(*dst)[i0]);
            }
        }
    }
    {
        long size0;
        const struct _Mind_VirtualItem *src0 = (const struct _Mind_VirtualItem *)from->learnedVirtualItems;
        std::vector< ::Mind::VirtualItem > *dst = &to->learnedVirtualItems();

        size0 = c_arraySize(c_sequence(from->learnedVirtualItems));
        to->learnedVirtualItems().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
        extern void __Mind_VirtualItem__copyOut(const void *from, void *to);
                __Mind_VirtualItem__copyOut((const void *)&src0[i0], (void *)&(*dst)[i0]);
            }
        }
    }
    {
        long size0;
        const struct _Mind_ConfiguredItem *src0 = (const struct _Mind_ConfiguredItem *)from->defaultConfiguredItems;
        std::vector< ::Mind::ConfiguredItem > *dst = &to->defaultConfiguredItems();

        size0 = c_arraySize(c_sequence(from->defaultConfiguredItems));
        to->defaultConfiguredItems().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
        extern void __Mind_ConfiguredItem__copyOut(const void *from, void *to);
                __Mind_ConfiguredItem__copyOut((const void *)&src0[i0], (void *)&(*dst)[i0]);
            }
        }
    }
    {
        long size0;
        const struct _Mind_ConfiguredItem *src0 = (const struct _Mind_ConfiguredItem *)from->preferredConfiguredItems;
        std::vector< ::Mind::ConfiguredItem > *dst = &to->preferredConfiguredItems();

        size0 = c_arraySize(c_sequence(from->preferredConfiguredItems));
        to->preferredConfiguredItems().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
        extern void __Mind_ConfiguredItem__copyOut(const void *from, void *to);
                __Mind_ConfiguredItem__copyOut((const void *)&src0[i0], (void *)&(*dst)[i0]);
            }
        }
    }
    {
        long size0;
        const struct _Mind_ConfiguredItem *src0 = (const struct _Mind_ConfiguredItem *)from->learnedConfiguredItems;
        std::vector< ::Mind::ConfiguredItem > *dst = &to->learnedConfiguredItems();

        size0 = c_arraySize(c_sequence(from->learnedConfiguredItems));
        to->learnedConfiguredItems().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
        extern void __Mind_ConfiguredItem__copyOut(const void *from, void *to);
                __Mind_ConfiguredItem__copyOut((const void *)&src0[i0], (void *)&(*dst)[i0]);
            }
        }
    }
}

void
__Mind_Configuration_Command_Set_Active_Item_Configuration__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Configuration_Command_Set_Active_Item_Configuration *from = (const struct _Mind_Configuration_Command_Set_Active_Item_Configuration *)_from;
    class ::Mind::Configuration_Command_Set_Active_Item_Configuration *to = (class ::Mind::Configuration_Command_Set_Active_Item_Configuration *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->activeItemConfiguration((::Mind::ConfigurationType)from->activeItemConfiguration);
}

void
__Mind_Configuration_Command_Set_Preferred_Virtual_Items_Configuration__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Configuration_Command_Set_Preferred_Virtual_Items_Configuration *from = (const struct _Mind_Configuration_Command_Set_Preferred_Virtual_Items_Configuration *)_from;
    class ::Mind::Configuration_Command_Set_Preferred_Virtual_Items_Configuration *to = (class ::Mind::Configuration_Command_Set_Preferred_Virtual_Items_Configuration *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    {
        long size0;
        const struct _Mind_VirtualItem *src0 = (const struct _Mind_VirtualItem *)from->preferredVirtualItems;
        std::vector< ::Mind::VirtualItem > *dst = &to->preferredVirtualItems();

        size0 = c_arraySize(c_sequence(from->preferredVirtualItems));
        to->preferredVirtualItems().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
        extern void __Mind_VirtualItem__copyOut(const void *from, void *to);
                __Mind_VirtualItem__copyOut((const void *)&src0[i0], (void *)&(*dst)[i0]);
            }
        }
    }
}

void
__Mind_Configuration_Command_Set_Preferred_Configured_Items_Configuration__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Configuration_Command_Set_Preferred_Configured_Items_Configuration *from = (const struct _Mind_Configuration_Command_Set_Preferred_Configured_Items_Configuration *)_from;
    class ::Mind::Configuration_Command_Set_Preferred_Configured_Items_Configuration *to = (class ::Mind::Configuration_Command_Set_Preferred_Configured_Items_Configuration *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    {
        long size0;
        const struct _Mind_ConfiguredItem *src0 = (const struct _Mind_ConfiguredItem *)from->preferredConfiguredItems;
        std::vector< ::Mind::ConfiguredItem > *dst = &to->preferredConfiguredItems();

        size0 = c_arraySize(c_sequence(from->preferredConfiguredItems));
        to->preferredConfiguredItems().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
        extern void __Mind_ConfiguredItem__copyOut(const void *from, void *to);
                __Mind_ConfiguredItem__copyOut((const void *)&src0[i0], (void *)&(*dst)[i0]);
            }
        }
    }
}

