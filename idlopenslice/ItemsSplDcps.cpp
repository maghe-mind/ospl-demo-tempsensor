#include "Items_DCPS.hpp"

#include <v_copyIn.h>
#include <v_topic.h>
#include <os_stdlib.h>
#include <string.h>
#include <os_report.h>

v_copyin_result
__Mind_User_Command__copyIn(
    c_base base,
    const class ::Mind::User_Command *from,
    struct _Mind_User_Command *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
    if((((c_long)from->itemCategory_) >= 0) && (((c_long)from->itemCategory_) < 121) ){
        to->itemCategory = (enum _Mind_Category)from->itemCategory_;
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'Mind::User_Command.itemCategory' of type 'Category' is out of range.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->itemCategory = (enum _Mind_Category)from->itemCategory_;
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->command = c_stringNew_s(base, from->command_.c_str());
        if(to->command == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->command = c_stringNew_s(base, from->command_.c_str());
            if(to->command == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Item_Command__copyIn(
    c_base base,
    const class ::Mind::Item_Command *from,
    struct _Mind_Item_Command *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
    if((((c_long)from->itemCategory_) >= 0) && (((c_long)from->itemCategory_) < 121) ){
        to->itemCategory = (enum _Mind_Category)from->itemCategory_;
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'Mind::Item_Command.itemCategory' of type 'Category' is out of range.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->itemCategory = (enum _Mind_Category)from->itemCategory_;
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->command = c_stringNew_s(base, from->command_.c_str());
        if(to->command == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->command = c_stringNew_s(base, from->command_.c_str());
            if(to->command == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Actuation_Command__copyIn(
    c_base base,
    const class ::Mind::Actuation_Command *from,
    struct _Mind_Actuation_Command *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        struct _Mind_Item_Command *dest0;
        const ::Mind::Actuation_Command::_commands_seq *src = &from->commands_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Item_Command"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Item_Command>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (struct _Mind_Item_Command *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
                extern v_copyin_result __Mind_Item_Command__copyIn(c_base base,
                    const Mind::Item_Command *From,
                    struct _Mind_Item_Command *To);

                result = __Mind_Item_Command__copyIn(base, &(*src)[i0], (struct _Mind_Item_Command *)&dest0[i0]);
            }
            to->commands = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (struct _Mind_Item_Command *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
                extern v_copyin_result __Mind_Item_Command__copyIn(c_base base,
                    const Mind::Item_Command *From,
                    struct _Mind_Item_Command *To);

                result = __Mind_Item_Command__copyIn(base, &(*src)[i0], (struct _Mind_Item_Command *)&dest0[i0]);
            }
            to->commands = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    return result;
}

v_copyin_result
__Mind_Item_Command_Update_Category__copyIn(
    c_base base,
    const class ::Mind::Item_Command_Update_Category *from,
    struct _Mind_Item_Command_Update_Category *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
    if((((c_long)from->itemCategory_) >= 0) && (((c_long)from->itemCategory_) < 121) ){
        to->itemCategory = (enum _Mind_Category)from->itemCategory_;
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'Mind::Item_Command_Update_Category.itemCategory' of type 'Category' is out of range.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->itemCategory = (enum _Mind_Category)from->itemCategory_;
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->command = c_stringNew_s(base, from->command_.c_str());
        if(to->command == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->command = c_stringNew_s(base, from->command_.c_str());
            if(to->command == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Item_Consumption__copyIn(
    c_base base,
    const class ::Mind::Item_Consumption *from,
    struct _Mind_Item_Consumption *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
    if((((c_long)from->itemCategory_) >= 0) && (((c_long)from->itemCategory_) < 121) ){
        to->itemCategory = (enum _Mind_Category)from->itemCategory_;
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'Mind::Item_Consumption.itemCategory' of type 'Category' is out of range.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->itemCategory = (enum _Mind_Category)from->itemCategory_;
#endif
    to->power = (c_double)from->power_;
    to->energy = (c_double)from->energy_;
    to->timestamp = (c_long)from->timestamp_;
    return result;
}

v_copyin_result
__Mind_ExtractorFan__copyIn(
    c_base base,
    const class ::Mind::ExtractorFan *from,
    struct _Mind_ExtractorFan *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::ExtractorFan::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->physicalLocationUUIDAmbience = c_stringNew_s(base, from->physicalLocationUUIDAmbience_.c_str());
        if(to->physicalLocationUUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->physicalLocationUUIDAmbience = c_stringNew_s(base, from->physicalLocationUUIDAmbience_.c_str());
            if(to->physicalLocationUUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_VMC__copyIn(
    c_base base,
    const class ::Mind::VMC *from,
    struct _Mind_VMC *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::VMC::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->physicalLocationUUIDAmbience = c_stringNew_s(base, from->physicalLocationUUIDAmbience_.c_str());
        if(to->physicalLocationUUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->physicalLocationUUIDAmbience = c_stringNew_s(base, from->physicalLocationUUIDAmbience_.c_str());
            if(to->physicalLocationUUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_CappaAspirazione__copyIn(
    c_base base,
    const class ::Mind::CappaAspirazione *from,
    struct _Mind_CappaAspirazione *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddressOnOff = c_stringNew_s(base, from->MACAddressOnOff_.c_str());
        if(to->MACAddressOnOff == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddressOnOff = c_stringNew_s(base, from->MACAddressOnOff_.c_str());
            if(to->MACAddressOnOff == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelayOnOff = (c_long)from->numRelayOnOff_;
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddressLight = c_stringNew_s(base, from->MACAddressLight_.c_str());
        if(to->MACAddressLight == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddressLight = c_stringNew_s(base, from->MACAddressLight_.c_str());
            if(to->MACAddressLight == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelayLight = (c_long)from->numRelayLight_;
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddressSpeed1 = c_stringNew_s(base, from->MACAddressSpeed1_.c_str());
        if(to->MACAddressSpeed1 == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddressSpeed1 = c_stringNew_s(base, from->MACAddressSpeed1_.c_str());
            if(to->MACAddressSpeed1 == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelaySpeed1 = (c_long)from->numRelaySpeed1_;
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddressSpeed2 = c_stringNew_s(base, from->MACAddressSpeed2_.c_str());
        if(to->MACAddressSpeed2 == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddressSpeed2 = c_stringNew_s(base, from->MACAddressSpeed2_.c_str());
            if(to->MACAddressSpeed2 == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelaySpeed2 = (c_long)from->numRelaySpeed2_;
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddressSpeed3 = c_stringNew_s(base, from->MACAddressSpeed3_.c_str());
        if(to->MACAddressSpeed3 == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddressSpeed3 = c_stringNew_s(base, from->MACAddressSpeed3_.c_str());
            if(to->MACAddressSpeed3 == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelaySpeed3 = (c_long)from->numRelaySpeed3_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::CappaAspirazione::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connectedOnOff = (c_bool)from->connectedOnOff_;
    to->connectedLight = (c_bool)from->connectedLight_;
    to->connectedSpeed1 = (c_bool)from->connectedSpeed1_;
    to->connectedSpeed2 = (c_bool)from->connectedSpeed2_;
    to->connectedSpeed3 = (c_bool)from->connectedSpeed3_;
    to->statusOnOff = (c_long)from->statusOnOff_;
    to->statusLight = (c_long)from->statusLight_;
    to->statusSpeed1 = (c_long)from->statusSpeed1_;
    to->statusSpeed2 = (c_long)from->statusSpeed2_;
    to->statusSpeed3 = (c_long)from->statusSpeed3_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Light__copyIn(
    c_base base,
    const class ::Mind::Light *from,
    struct _Mind_Light *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::Light::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->physicalLocationUUIDAmbience = c_stringNew_s(base, from->physicalLocationUUIDAmbience_.c_str());
        if(to->physicalLocationUUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->physicalLocationUUIDAmbience = c_stringNew_s(base, from->physicalLocationUUIDAmbience_.c_str());
            if(to->physicalLocationUUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_LightDimmable__copyIn(
    c_base base,
    const class ::Mind::LightDimmable *from,
    struct _Mind_LightDimmable *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::LightDimmable::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
    to->hasFilter = (c_bool)from->hasFilter_;
#ifdef OSPL_BOUNDS_CHECK
        to->physicalLocationUUIDAmbience = c_stringNew_s(base, from->physicalLocationUUIDAmbience_.c_str());
        if(to->physicalLocationUUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->physicalLocationUUIDAmbience = c_stringNew_s(base, from->physicalLocationUUIDAmbience_.c_str());
            if(to->physicalLocationUUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_LightMind__copyIn(
    c_base base,
    const class ::Mind::LightMind *from,
    struct _Mind_LightMind *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::LightMind::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->statusDimmer = (c_long)from->statusDimmer_;
    to->statusTemperature = (c_long)from->statusTemperature_;
    to->status = (c_bool)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_LightMindLED__copyIn(
    c_base base,
    const class ::Mind::LightMindLED *from,
    struct _Mind_LightMindLED *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::LightMindLED::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->status = (c_bool)from->status_;
    to->r = (c_long)from->r_;
    to->g = (c_long)from->g_;
    to->b = (c_long)from->b_;
    to->w = (c_long)from->w_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_BSwitch__copyIn(
    c_base base,
    const class ::Mind::BSwitch *from,
    struct _Mind_BSwitch *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numInput = (c_long)from->numInput_;
    to->status = (c_long)from->status_;
    to->connected = (c_bool)from->connected_;
    to->disabled = (c_bool)from->disabled_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::BSwitch::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Button__copyIn(
    c_base base,
    const class ::Mind::Button *from,
    struct _Mind_Button *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numInput = (c_long)from->numInput_;
    to->status = (c_long)from->status_;
    to->connected = (c_bool)from->connected_;
    to->disabled = (c_bool)from->disabled_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::Button::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_ShutterButton__copyIn(
    c_base base,
    const class ::Mind::ShutterButton *from,
    struct _Mind_ShutterButton *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDShutter = c_stringNew_s(base, from->UUIDShutter_.c_str());
        if(to->UUIDShutter == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDShutter = c_stringNew_s(base, from->UUIDShutter_.c_str());
            if(to->UUIDShutter == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numInput = (c_long)from->numInput_;
    to->status = (c_long)from->status_;
    to->connected = (c_bool)from->connected_;
    to->disabled = (c_bool)from->disabled_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->updownType = (c_bool)from->updownType_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::ShutterButton::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_DoorContact__copyIn(
    c_base base,
    const class ::Mind::DoorContact *from,
    struct _Mind_DoorContact *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numInput = (c_long)from->numInput_;
    to->status = (c_long)from->status_;
    to->connected = (c_bool)from->connected_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->disabled = (c_bool)from->disabled_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::DoorContact::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_WindowContact__copyIn(
    c_base base,
    const class ::Mind::WindowContact *from,
    struct _Mind_WindowContact *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numInput = (c_long)from->numInput_;
    to->status = (c_long)from->status_;
    to->connected = (c_bool)from->connected_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->disabled = (c_bool)from->disabled_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::WindowContact::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Tamper__copyIn(
    c_base base,
    const class ::Mind::Tamper *from,
    struct _Mind_Tamper *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numInput = (c_long)from->numInput_;
    to->status = (c_long)from->status_;
    to->connected = (c_bool)from->connected_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->disabled = (c_bool)from->disabled_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::Tamper::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_PIRContact__copyIn(
    c_base base,
    const class ::Mind::PIRContact *from,
    struct _Mind_PIRContact *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numInput = (c_long)from->numInput_;
    to->status = (c_long)from->status_;
    to->connected = (c_bool)from->connected_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->disabled = (c_bool)from->disabled_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::PIRContact::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_RollerShutter__copyIn(
    c_base base,
    const class ::Mind::RollerShutter *from,
    struct _Mind_RollerShutter *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->status = (c_long)from->status_;
    to->numRelay = (c_long)from->numRelay_;
    to->connected = (c_bool)from->connected_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::RollerShutter::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Scuro__copyIn(
    c_base base,
    const class ::Mind::Scuro *from,
    struct _Mind_Scuro *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->status = (c_long)from->status_;
    to->numRelay = (c_long)from->numRelay_;
    to->connected = (c_bool)from->connected_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::Scuro::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Frangisole__copyIn(
    c_base base,
    const class ::Mind::Frangisole *from,
    struct _Mind_Frangisole *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->status = (c_long)from->status_;
    to->numRelay = (c_long)from->numRelay_;
    to->connected = (c_bool)from->connected_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::Frangisole::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Blinds__copyIn(
    c_base base,
    const class ::Mind::Blinds *from,
    struct _Mind_Blinds *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->status = (c_long)from->status_;
    to->numRelay = (c_long)from->numRelay_;
    to->connected = (c_bool)from->connected_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::Blinds::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Veneziana__copyIn(
    c_base base,
    const class ::Mind::Veneziana *from,
    struct _Mind_Veneziana *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->status = (c_long)from->status_;
    to->numRelay = (c_long)from->numRelay_;
    to->connected = (c_bool)from->connected_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::Veneziana::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Grata__copyIn(
    c_base base,
    const class ::Mind::Grata *from,
    struct _Mind_Grata *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->status = (c_long)from->status_;
    to->numRelay = (c_long)from->numRelay_;
    to->connected = (c_bool)from->connected_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::Grata::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Forno__copyIn(
    c_base base,
    const class ::Mind::Forno *from,
    struct _Mind_Forno *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::Forno::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_FornoMicroonde__copyIn(
    c_base base,
    const class ::Mind::FornoMicroonde *from,
    struct _Mind_FornoMicroonde *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::FornoMicroonde::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Frigo__copyIn(
    c_base base,
    const class ::Mind::Frigo *from,
    struct _Mind_Frigo *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::Frigo::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Freezer__copyIn(
    c_base base,
    const class ::Mind::Freezer *from,
    struct _Mind_Freezer *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::Freezer::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_CantinaVini__copyIn(
    c_base base,
    const class ::Mind::CantinaVini *from,
    struct _Mind_CantinaVini *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::CantinaVini::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_MacchinaCaffe__copyIn(
    c_base base,
    const class ::Mind::MacchinaCaffe *from,
    struct _Mind_MacchinaCaffe *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::MacchinaCaffe::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_PianoCottura__copyIn(
    c_base base,
    const class ::Mind::PianoCottura *from,
    struct _Mind_PianoCottura *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::PianoCottura::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Lavatrice__copyIn(
    c_base base,
    const class ::Mind::Lavatrice *from,
    struct _Mind_Lavatrice *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::Lavatrice::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Lavastoviglie__copyIn(
    c_base base,
    const class ::Mind::Lavastoviglie *from,
    struct _Mind_Lavastoviglie *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::Lavastoviglie::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Asciugatrice__copyIn(
    c_base base,
    const class ::Mind::Asciugatrice *from,
    struct _Mind_Asciugatrice *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::Asciugatrice::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_ColonnettaTesla__copyIn(
    c_base base,
    const class ::Mind::ColonnettaTesla *from,
    struct _Mind_ColonnettaTesla *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::ColonnettaTesla::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Impianto__copyIn(
    c_base base,
    const class ::Mind::Impianto *from,
    struct _Mind_Impianto *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::Impianto::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_IrrigationPump__copyIn(
    c_base base,
    const class ::Mind::IrrigationPump *from,
    struct _Mind_IrrigationPump *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::IrrigationPump::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Siren__copyIn(
    c_base base,
    const class ::Mind::Siren *from,
    struct _Mind_Siren *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::Siren::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_CancelloCarraio__copyIn(
    c_base base,
    const class ::Mind::CancelloCarraio *from,
    struct _Mind_CancelloCarraio *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::CancelloCarraio::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_CancelloPedonale__copyIn(
    c_base base,
    const class ::Mind::CancelloPedonale *from,
    struct _Mind_CancelloPedonale *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::CancelloPedonale::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_CancelloGarage__copyIn(
    c_base base,
    const class ::Mind::CancelloGarage *from,
    struct _Mind_CancelloGarage *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::CancelloGarage::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_GasValve__copyIn(
    c_base base,
    const class ::Mind::GasValve *from,
    struct _Mind_GasValve *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::GasValve::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_WaterValve__copyIn(
    c_base base,
    const class ::Mind::WaterValve *from,
    struct _Mind_WaterValve *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::WaterValve::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_PompaRicircolo__copyIn(
    c_base base,
    const class ::Mind::PompaRicircolo *from,
    struct _Mind_PompaRicircolo *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::PompaRicircolo::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Socket_16A__copyIn(
    c_base base,
    const class ::Mind::Socket_16A *from,
    struct _Mind_Socket_16A *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::Socket_16A::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->physicalLocationUUIDAmbience = c_stringNew_s(base, from->physicalLocationUUIDAmbience_.c_str());
        if(to->physicalLocationUUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->physicalLocationUUIDAmbience = c_stringNew_s(base, from->physicalLocationUUIDAmbience_.c_str());
            if(to->physicalLocationUUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Socket_5A__copyIn(
    c_base base,
    const class ::Mind::Socket_5A *from,
    struct _Mind_Socket_5A *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::Socket_5A::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
    to->hasFilter = (c_bool)from->hasFilter_;
#ifdef OSPL_BOUNDS_CHECK
        to->physicalLocationUUIDAmbience = c_stringNew_s(base, from->physicalLocationUUIDAmbience_.c_str());
        if(to->physicalLocationUUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->physicalLocationUUIDAmbience = c_stringNew_s(base, from->physicalLocationUUIDAmbience_.c_str());
            if(to->physicalLocationUUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_VoiceCommand__copyIn(
    c_base base,
    const class ::Mind::VoiceCommand *from,
    struct _Mind_VoiceCommand *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->text = c_stringNew_s(base, from->text_.c_str());
        if(to->text == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->text = c_stringNew_s(base, from->text_.c_str());
            if(to->text == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_PresaMultimediale__copyIn(
    c_base base,
    const class ::Mind::PresaMultimediale *from,
    struct _Mind_PresaMultimediale *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::PresaMultimediale::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_HarmonyMultimedia__copyIn(
    c_base base,
    const class ::Mind::HarmonyMultimedia *from,
    struct _Mind_HarmonyMultimedia *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->IPAddress = c_stringNew_s(base, from->IPAddress_.c_str());
        if(to->IPAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->IPAddress = c_stringNew_s(base, from->IPAddress_.c_str());
            if(to->IPAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->currentActivity = c_stringNew_s(base, from->currentActivity_.c_str());
        if(to->currentActivity == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->currentActivity = c_stringNew_s(base, from->currentActivity_.c_str());
            if(to->currentActivity == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        c_string *dest0;
        const ::Mind::HarmonyMultimedia::_availableActivities_seq *src = &from->availableActivities_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "c_string"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<c_string>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (c_string *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
#ifdef OSPL_BOUNDS_CHECK
                if((*src)[i0]){
                    dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                    if(dest0[i0] == NULL) {
                        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                    }
                } else {
                    OS_REPORT (OS_ERROR, "copyIn", 0,"Element of 'Mind::HarmonyMultimedia.*src' of type 'c_string' is NULL.");
                    result = V_COPYIN_RESULT_INVALID;
                }
#else
                dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                if(dest0[i0] == NULL) {
                    result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                }
#endif
            }
            to->availableActivities = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (c_string *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
#ifdef OSPL_BOUNDS_CHECK
                if((*src)[i0]){
                    dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                    if(dest0[i0] == NULL) {
                        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                    }
                } else {
                    OS_REPORT (OS_ERROR, "copyIn", 0,"Element of 'Mind::HarmonyMultimedia.*src' of type 'c_string' is NULL.");
                    result = V_COPYIN_RESULT_INVALID;
                }
#else
                dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                if(dest0[i0] == NULL) {
                    result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                }
#endif
            }
            to->availableActivities = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::HarmonyMultimedia::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
#ifdef OSPL_BOUNDS_CHECK
        to->name = c_stringNew_s(base, from->name_.c_str());
        if(to->name == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->name = c_stringNew_s(base, from->name_.c_str());
            if(to->name == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_MindSound__copyIn(
    c_base base,
    const class ::Mind::MindSound *from,
    struct _Mind_MindSound *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->currentSound = c_stringNew_s(base, from->currentSound_.c_str());
        if(to->currentSound == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->currentSound = c_stringNew_s(base, from->currentSound_.c_str());
            if(to->currentSound == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->enabled = (c_bool)from->enabled_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_TransportData__copyIn(
    c_base base,
    const class ::Mind::TransportData *from,
    struct _Mind_TransportData *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->title = c_stringNew_s(base, from->title_.c_str());
        if(to->title == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->title = c_stringNew_s(base, from->title_.c_str());
            if(to->title == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->artist = c_stringNew_s(base, from->artist_.c_str());
        if(to->artist == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->artist = c_stringNew_s(base, from->artist_.c_str());
            if(to->artist == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->uri = c_stringNew_s(base, from->uri_.c_str());
        if(to->uri == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->uri = c_stringNew_s(base, from->uri_.c_str());
            if(to->uri == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->queueSize = (c_long)from->queueSize_;
#ifdef OSPL_BOUNDS_CHECK
        to->currentTrackDuration = c_stringNew_s(base, from->currentTrackDuration_.c_str());
        if(to->currentTrackDuration == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->currentTrackDuration = c_stringNew_s(base, from->currentTrackDuration_.c_str());
            if(to->currentTrackDuration == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->CurrentTransportActions = c_stringNew_s(base, from->CurrentTransportActions_.c_str());
        if(to->CurrentTransportActions == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->CurrentTransportActions = c_stringNew_s(base, from->CurrentTransportActions_.c_str());
            if(to->CurrentTransportActions == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
    if((((c_long)from->status_) >= 0) && (((c_long)from->status_) < 3) ){
        to->status = (enum _Mind_TransportStatus)from->status_;
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'Mind::TransportData.status' of type 'TransportStatus' is out of range.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->status = (enum _Mind_TransportStatus)from->status_;
#endif
    return result;
}

v_copyin_result
__Mind_RenderingData__copyIn(
    c_base base,
    const class ::Mind::RenderingData *from,
    struct _Mind_RenderingData *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

    to->volumeMaster = (c_long)from->volumeMaster_;
    to->volumeLF = (c_long)from->volumeLF_;
    to->volumeRF = (c_long)from->volumeRF_;
    to->muteMaster = (c_bool)from->muteMaster_;
    to->muteLF = (c_bool)from->muteLF_;
    to->muteRF = (c_bool)from->muteRF_;
    return result;
}

v_copyin_result
__Mind_Sonos__copyIn(
    c_base base,
    const class ::Mind::Sonos *from,
    struct _Mind_Sonos *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->zoneName = c_stringNew_s(base, from->zoneName_.c_str());
        if(to->zoneName == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->zoneName = c_stringNew_s(base, from->zoneName_.c_str());
            if(to->zoneName == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->uri = c_stringNew_s(base, from->uri_.c_str());
        if(to->uri == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->uri = c_stringNew_s(base, from->uri_.c_str());
            if(to->uri == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->coordinatorUUID = c_stringNew_s(base, from->coordinatorUUID_.c_str());
        if(to->coordinatorUUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->coordinatorUUID = c_stringNew_s(base, from->coordinatorUUID_.c_str());
            if(to->coordinatorUUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    if(V_COPYIN_RESULT_IS_OK(result)){
        extern v_copyin_result __Mind_TransportData__copyIn(c_base, const ::Mind::TransportData *, _Mind_TransportData *);
        result = __Mind_TransportData__copyIn(base, &from->transportData_, &to->transportData);
    }
    if(V_COPYIN_RESULT_IS_OK(result)){
        extern v_copyin_result __Mind_RenderingData__copyIn(c_base, const ::Mind::RenderingData *, _Mind_RenderingData *);
        result = __Mind_RenderingData__copyIn(base, &from->renderingData_, &to->renderingData);
    }
    to->connected = (c_bool)from->connected_;
    to->enabled = (c_bool)from->enabled_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::Sonos::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_ProjectionScreen__copyIn(
    c_base base,
    const class ::Mind::ProjectionScreen *from,
    struct _Mind_ProjectionScreen *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->status = (c_long)from->status_;
    to->numRelay = (c_long)from->numRelay_;
    to->connected = (c_bool)from->connected_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::ProjectionScreen::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Citofono__copyIn(
    c_base base,
    const class ::Mind::Citofono *from,
    struct _Mind_Citofono *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->IPAddress = c_stringNew_s(base, from->IPAddress_.c_str());
        if(to->IPAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->IPAddress = c_stringNew_s(base, from->IPAddress_.c_str());
            if(to->IPAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->status = (c_bool)from->status_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::Citofono::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_FloodingSensor__copyIn(
    c_base base,
    const class ::Mind::FloodingSensor *from,
    struct _Mind_FloodingSensor *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->IPAddress = c_stringNew_s(base, from->IPAddress_.c_str());
        if(to->IPAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->IPAddress = c_stringNew_s(base, from->IPAddress_.c_str());
            if(to->IPAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->status = (c_bool)from->status_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::FloodingSensor::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_EnvironmentalSensor__copyIn(
    c_base base,
    const class ::Mind::EnvironmentalSensor *from,
    struct _Mind_EnvironmentalSensor *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::EnvironmentalSensor::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->temperature = (c_double)from->temperature_;
    to->CO = (c_double)from->CO_;
    to->CO2 = (c_double)from->CO2_;
    to->humidity = (c_double)from->humidity_;
    to->VOC = (c_double)from->VOC_;
    to->smoke = (c_double)from->smoke_;
#ifdef OSPL_BOUNDS_CHECK
        to->timestamp = c_stringNew_s(base, from->timestamp_.c_str());
        if(to->timestamp == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->timestamp = c_stringNew_s(base, from->timestamp_.c_str());
            if(to->timestamp == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_VisionEnvironmentalSensor__copyIn(
    c_base base,
    const class ::Mind::VisionEnvironmentalSensor *from,
    struct _Mind_VisionEnvironmentalSensor *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::VisionEnvironmentalSensor::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->brightness = (c_double)from->brightness_;
    to->motion = (c_double)from->motion_;
#ifdef OSPL_BOUNDS_CHECK
        to->timestamp = c_stringNew_s(base, from->timestamp_.c_str());
        if(to->timestamp == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->timestamp = c_stringNew_s(base, from->timestamp_.c_str());
            if(to->timestamp == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_VisionPeopleSensor__copyIn(
    c_base base,
    const class ::Mind::VisionPeopleSensor *from,
    struct _Mind_VisionPeopleSensor *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::VisionPeopleSensor::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->peopleCount = (c_long)from->peopleCount_;
    to->knownPeopleCount = (c_long)from->knownPeopleCount_;
    to->unknownPeopleCount = (c_long)from->unknownPeopleCount_;
    to->faceCount = (c_long)from->faceCount_;
#ifdef OSPL_BOUNDS_CHECK
        to->timestamp = c_stringNew_s(base, from->timestamp_.c_str());
        if(to->timestamp == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->timestamp = c_stringNew_s(base, from->timestamp_.c_str());
            if(to->timestamp == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_PowerSensor__copyIn(
    c_base base,
    const class ::Mind::PowerSensor *from,
    struct _Mind_PowerSensor *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->consumption = (c_double)from->consumption_;
#ifdef OSPL_BOUNDS_CHECK
        to->timestamp = c_stringNew_s(base, from->timestamp_.c_str());
        if(to->timestamp == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->timestamp = c_stringNew_s(base, from->timestamp_.c_str());
            if(to->timestamp == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_BluetoothIdentitySensor__copyIn(
    c_base base,
    const class ::Mind::BluetoothIdentitySensor *from,
    struct _Mind_BluetoothIdentitySensor *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->probability = (c_double)from->probability_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_VisionIdentitySensor__copyIn(
    c_base base,
    const class ::Mind::VisionIdentitySensor *from,
    struct _Mind_VisionIdentitySensor *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->probability = (c_double)from->probability_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Thermostat__copyIn(
    c_base base,
    const class ::Mind::Thermostat *from,
    struct _Mind_Thermostat *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->targetTemperature = (c_double)from->targetTemperature_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_CurrentWeather__copyIn(
    c_base base,
    const class ::Mind::CurrentWeather *from,
    struct _Mind_CurrentWeather *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

    to->referenceTimestamp = (c_long)from->referenceTimestamp_;
    to->temperature = (c_double)from->temperature_;
    to->pressure = (c_double)from->pressure_;
    to->humidity = (c_double)from->humidity_;
    to->windKph = (c_double)from->windKph_;
    to->uv = (c_double)from->uv_;
    to->cloudiness = (c_long)from->cloudiness_;
    to->conditionCode = (c_long)from->conditionCode_;
#ifdef OSPL_BOUNDS_CHECK
        to->conditionName = c_stringNew_s(base, from->conditionName_.c_str());
        if(to->conditionName == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->conditionName = c_stringNew_s(base, from->conditionName_.c_str());
            if(to->conditionName == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->nextSunrise = c_stringNew_s(base, from->nextSunrise_.c_str());
        if(to->nextSunrise == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->nextSunrise = c_stringNew_s(base, from->nextSunrise_.c_str());
            if(to->nextSunrise == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->nextSunset = c_stringNew_s(base, from->nextSunset_.c_str());
        if(to->nextSunset == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->nextSunset = c_stringNew_s(base, from->nextSunset_.c_str());
            if(to->nextSunset == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_HourlyWeatherData__copyIn(
    c_base base,
    const class ::Mind::HourlyWeatherData *from,
    struct _Mind_HourlyWeatherData *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

    to->referenceTimestamp = (c_long)from->referenceTimestamp_;
    to->windKph = (c_double)from->windKph_;
    to->temperature = (c_double)from->temperature_;
    to->rainChance = (c_long)from->rainChance_;
    to->willItRain = (c_bool)from->willItRain_;
    to->isDay = (c_bool)from->isDay_;
    to->conditionCode = (c_long)from->conditionCode_;
#ifdef OSPL_BOUNDS_CHECK
        to->conditionName = c_stringNew_s(base, from->conditionName_.c_str());
        if(to->conditionName == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->conditionName = c_stringNew_s(base, from->conditionName_.c_str());
            if(to->conditionName == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->cloudiness = (c_long)from->cloudiness_;
    to->precipMm = (c_double)from->precipMm_;
    return result;
}

v_copyin_result
__Mind_DailyWeatherData__copyIn(
    c_base base,
    const class ::Mind::DailyWeatherData *from,
    struct _Mind_DailyWeatherData *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

    to->referenceTimestamp = (c_long)from->referenceTimestamp_;
    to->maxTemperature = (c_double)from->maxTemperature_;
    to->temperature = (c_double)from->temperature_;
    to->minTemperature = (c_double)from->minTemperature_;
    to->precipMm = (c_double)from->precipMm_;
    to->conditionCode = (c_long)from->conditionCode_;
#ifdef OSPL_BOUNDS_CHECK
        to->conditionName = c_stringNew_s(base, from->conditionName_.c_str());
        if(to->conditionName == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->conditionName = c_stringNew_s(base, from->conditionName_.c_str());
            if(to->conditionName == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->uv = (c_double)from->uv_;
    return result;
}

v_copyin_result
__Mind_HistoricalAndForecastedWeather__copyIn(
    c_base base,
    const class ::Mind::HistoricalAndForecastedWeather *from,
    struct _Mind_HistoricalAndForecastedWeather *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

    to->lastUpdateTimestamp = (c_long)from->lastUpdateTimestamp_;
    if(V_COPYIN_RESULT_IS_OK(result)){
        extern v_copyin_result __Mind_DailyWeatherData__copyIn(c_base, const ::Mind::DailyWeatherData *, _Mind_DailyWeatherData *);
        result = __Mind_DailyWeatherData__copyIn(base, &from->tomorrow_, &to->tomorrow);
    }
    if(V_COPYIN_RESULT_IS_OK(result)){
        extern v_copyin_result __Mind_DailyWeatherData__copyIn(c_base, const ::Mind::DailyWeatherData *, _Mind_DailyWeatherData *);
        result = __Mind_DailyWeatherData__copyIn(base, &from->today_, &to->today);
    }
    if(V_COPYIN_RESULT_IS_OK(result)){
        extern v_copyin_result __Mind_DailyWeatherData__copyIn(c_base, const ::Mind::DailyWeatherData *, _Mind_DailyWeatherData *);
        result = __Mind_DailyWeatherData__copyIn(base, &from->yesterday_, &to->yesterday);
    }
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        struct _Mind_HourlyWeatherData *dest0;
        const ::Mind::HistoricalAndForecastedWeather::_hourlyForecast_seq *src = &from->hourlyForecast_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::HourlyWeatherData"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::HourlyWeatherData>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (struct _Mind_HourlyWeatherData *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
                extern v_copyin_result __Mind_HourlyWeatherData__copyIn(c_base base,
                    const Mind::HourlyWeatherData *From,
                    struct _Mind_HourlyWeatherData *To);

                result = __Mind_HourlyWeatherData__copyIn(base, &(*src)[i0], (struct _Mind_HourlyWeatherData *)&dest0[i0]);
            }
            to->hourlyForecast = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (struct _Mind_HourlyWeatherData *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
                extern v_copyin_result __Mind_HourlyWeatherData__copyIn(c_base base,
                    const Mind::HourlyWeatherData *From,
                    struct _Mind_HourlyWeatherData *To);

                result = __Mind_HourlyWeatherData__copyIn(base, &(*src)[i0], (struct _Mind_HourlyWeatherData *)&dest0[i0]);
            }
            to->hourlyForecast = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        struct _Mind_HourlyWeatherData *dest0;
        const ::Mind::HistoricalAndForecastedWeather::_hourlyHistory_seq *src = &from->hourlyHistory_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::HourlyWeatherData"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::HourlyWeatherData>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (struct _Mind_HourlyWeatherData *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
                extern v_copyin_result __Mind_HourlyWeatherData__copyIn(c_base base,
                    const Mind::HourlyWeatherData *From,
                    struct _Mind_HourlyWeatherData *To);

                result = __Mind_HourlyWeatherData__copyIn(base, &(*src)[i0], (struct _Mind_HourlyWeatherData *)&dest0[i0]);
            }
            to->hourlyHistory = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (struct _Mind_HourlyWeatherData *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
                extern v_copyin_result __Mind_HourlyWeatherData__copyIn(c_base base,
                    const Mind::HourlyWeatherData *From,
                    struct _Mind_HourlyWeatherData *To);

                result = __Mind_HourlyWeatherData__copyIn(base, &(*src)[i0], (struct _Mind_HourlyWeatherData *)&dest0[i0]);
            }
            to->hourlyHistory = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    return result;
}

v_copyin_result
__Mind_Caldaia__copyIn(
    c_base base,
    const class ::Mind::Caldaia *from,
    struct _Mind_Caldaia *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::Caldaia::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_PompaCalore__copyIn(
    c_base base,
    const class ::Mind::PompaCalore *from,
    struct _Mind_PompaCalore *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddressOnOff = c_stringNew_s(base, from->MACAddressOnOff_.c_str());
        if(to->MACAddressOnOff == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddressOnOff = c_stringNew_s(base, from->MACAddressOnOff_.c_str());
            if(to->MACAddressOnOff == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelayOnOff = (c_long)from->numRelayOnOff_;
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddressCF = c_stringNew_s(base, from->MACAddressCF_.c_str());
        if(to->MACAddressCF == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddressCF = c_stringNew_s(base, from->MACAddressCF_.c_str());
            if(to->MACAddressCF == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelayCF = (c_long)from->numRelayCF_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::PompaCalore::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connectedOnOff = (c_bool)from->connectedOnOff_;
    to->connectedCF = (c_bool)from->connectedCF_;
    to->statusOnOff = (c_bool)from->statusOnOff_;
    to->statusCF = (c_bool)from->statusCF_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_FloorHeating__copyIn(
    c_base base,
    const class ::Mind::FloorHeating *from,
    struct _Mind_FloorHeating *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::FloorHeating::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        c_string *dest0;
        const ::Mind::FloorHeating::_UUIDAmbiences_seq *src = &from->UUIDAmbiences_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "c_string"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<c_string>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (c_string *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
#ifdef OSPL_BOUNDS_CHECK
                if((*src)[i0]){
                    dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                    if(dest0[i0] == NULL) {
                        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                    }
                } else {
                    OS_REPORT (OS_ERROR, "copyIn", 0,"Element of 'Mind::FloorHeating.*src' of type 'c_string' is NULL.");
                    result = V_COPYIN_RESULT_INVALID;
                }
#else
                dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                if(dest0[i0] == NULL) {
                    result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                }
#endif
            }
            to->UUIDAmbiences = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (c_string *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
#ifdef OSPL_BOUNDS_CHECK
                if((*src)[i0]){
                    dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                    if(dest0[i0] == NULL) {
                        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                    }
                } else {
                    OS_REPORT (OS_ERROR, "copyIn", 0,"Element of 'Mind::FloorHeating.*src' of type 'c_string' is NULL.");
                    result = V_COPYIN_RESULT_INVALID;
                }
#else
                dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                if(dest0[i0] == NULL) {
                    result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                }
#endif
            }
            to->UUIDAmbiences = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_FanCoil__copyIn(
    c_base base,
    const class ::Mind::FanCoil *from,
    struct _Mind_FanCoil *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddressOnOff = c_stringNew_s(base, from->MACAddressOnOff_.c_str());
        if(to->MACAddressOnOff == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddressOnOff = c_stringNew_s(base, from->MACAddressOnOff_.c_str());
            if(to->MACAddressOnOff == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelayOnOff = (c_long)from->numRelayOnOff_;
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddressSpeed1 = c_stringNew_s(base, from->MACAddressSpeed1_.c_str());
        if(to->MACAddressSpeed1 == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddressSpeed1 = c_stringNew_s(base, from->MACAddressSpeed1_.c_str());
            if(to->MACAddressSpeed1 == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelaySpeed1 = (c_long)from->numRelaySpeed1_;
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddressSpeed2 = c_stringNew_s(base, from->MACAddressSpeed2_.c_str());
        if(to->MACAddressSpeed2 == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddressSpeed2 = c_stringNew_s(base, from->MACAddressSpeed2_.c_str());
            if(to->MACAddressSpeed2 == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelaySpeed2 = (c_long)from->numRelaySpeed2_;
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddressSpeed3 = c_stringNew_s(base, from->MACAddressSpeed3_.c_str());
        if(to->MACAddressSpeed3 == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddressSpeed3 = c_stringNew_s(base, from->MACAddressSpeed3_.c_str());
            if(to->MACAddressSpeed3 == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelaySpeed3 = (c_long)from->numRelaySpeed3_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::FanCoil::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connectedOnOff = (c_bool)from->connectedOnOff_;
    to->connectedSpeed1 = (c_bool)from->connectedSpeed1_;
    to->connectedSpeed2 = (c_bool)from->connectedSpeed2_;
    to->connectedSpeed3 = (c_bool)from->connectedSpeed3_;
    to->statusOnOff = (c_long)from->statusOnOff_;
    to->statusSpeed1 = (c_long)from->statusSpeed1_;
    to->statusSpeed2 = (c_long)from->statusSpeed2_;
    to->statusSpeed3 = (c_long)from->statusSpeed3_;
    to->blocked = (c_bool)from->blocked_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        c_string *dest0;
        const ::Mind::FanCoil::_UUIDAmbiences_seq *src = &from->UUIDAmbiences_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "c_string"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<c_string>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (c_string *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
#ifdef OSPL_BOUNDS_CHECK
                if((*src)[i0]){
                    dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                    if(dest0[i0] == NULL) {
                        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                    }
                } else {
                    OS_REPORT (OS_ERROR, "copyIn", 0,"Element of 'Mind::FanCoil.*src' of type 'c_string' is NULL.");
                    result = V_COPYIN_RESULT_INVALID;
                }
#else
                dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                if(dest0[i0] == NULL) {
                    result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                }
#endif
            }
            to->UUIDAmbiences = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (c_string *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
#ifdef OSPL_BOUNDS_CHECK
                if((*src)[i0]){
                    dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                    if(dest0[i0] == NULL) {
                        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                    }
                } else {
                    OS_REPORT (OS_ERROR, "copyIn", 0,"Element of 'Mind::FanCoil.*src' of type 'c_string' is NULL.");
                    result = V_COPYIN_RESULT_INVALID;
                }
#else
                dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                if(dest0[i0] == NULL) {
                    result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                }
#endif
            }
            to->UUIDAmbiences = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_CoolingFan__copyIn(
    c_base base,
    const class ::Mind::CoolingFan *from,
    struct _Mind_CoolingFan *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
        if(to->MACAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddress = c_stringNew_s(base, from->MACAddress_.c_str());
            if(to->MACAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->numRelay = (c_long)from->numRelay_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::CoolingFan::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->connected = (c_bool)from->connected_;
    to->status = (c_long)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    to->blocked = (c_bool)from->blocked_;
#ifdef OSPL_BOUNDS_CHECK
        to->physicalLocationUUIDAmbience = c_stringNew_s(base, from->physicalLocationUUIDAmbience_.c_str());
        if(to->physicalLocationUUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->physicalLocationUUIDAmbience = c_stringNew_s(base, from->physicalLocationUUIDAmbience_.c_str());
            if(to->physicalLocationUUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_HarmonySplit__copyIn(
    c_base base,
    const class ::Mind::HarmonySplit *from,
    struct _Mind_HarmonySplit *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->IPAddress = c_stringNew_s(base, from->IPAddress_.c_str());
        if(to->IPAddress == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->IPAddress = c_stringNew_s(base, from->IPAddress_.c_str());
            if(to->IPAddress == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::HarmonySplit::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->temperature = (c_long)from->temperature_;
    to->deumidifica = (c_bool)from->deumidifica_;
    to->speed = (c_long)from->speed_;
    to->airOrientation = (c_long)from->airOrientation_;
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        c_string *dest0;
        const ::Mind::HarmonySplit::_UUIDAmbience_seq *src = &from->UUIDAmbience_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "c_string"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<c_string>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (c_string *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
#ifdef OSPL_BOUNDS_CHECK
                if((*src)[i0]){
                    dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                    if(dest0[i0] == NULL) {
                        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                    }
                } else {
                    OS_REPORT (OS_ERROR, "copyIn", 0,"Element of 'Mind::HarmonySplit.*src' of type 'c_string' is NULL.");
                    result = V_COPYIN_RESULT_INVALID;
                }
#else
                dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                if(dest0[i0] == NULL) {
                    result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                }
#endif
            }
            to->UUIDAmbience = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (c_string *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
#ifdef OSPL_BOUNDS_CHECK
                if((*src)[i0]){
                    dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                    if(dest0[i0] == NULL) {
                        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                    }
                } else {
                    OS_REPORT (OS_ERROR, "copyIn", 0,"Element of 'Mind::HarmonySplit.*src' of type 'c_string' is NULL.");
                    result = V_COPYIN_RESULT_INVALID;
                }
#else
                dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                if(dest0[i0] == NULL) {
                    result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                }
#endif
            }
            to->UUIDAmbience = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Termosifone__copyIn(
    c_base base,
    const class ::Mind::Termosifone *from,
    struct _Mind_Termosifone *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
        to->UUID = c_stringNew_s(base, from->UUID_.c_str());
        if(to->UUID == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUID = c_stringNew_s(base, from->UUID_.c_str());
            if(to->UUID == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->MACAddressBT = c_stringNew_s(base, from->MACAddressBT_.c_str());
        if(to->MACAddressBT == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->MACAddressBT = c_stringNew_s(base, from->MACAddressBT_.c_str());
            if(to->MACAddressBT == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        enum _Mind_Category *dest0;
        const ::Mind::Termosifone::_categories_seq *src = &from->categories_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::Category"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::Category>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (enum _Mind_Category *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const enum _Mind_Category *buf0;
                buf0 = reinterpret_cast<const enum _Mind_Category *>(&((*src)[0]));
#ifdef OSPL_BOUNDS_CHECK
                /* TODO: Validate enum elements here - Xref issue dds#175  */
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#else
                memcpy (dest0,buf0,length0* sizeof(*dest0));
#endif
            }
            to->categories = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
    to->batteryStatus = (c_double)from->batteryStatus_;
    to->connected = (c_bool)from->connected_;
    to->status = (c_bool)from->status_;
#ifdef OSPL_BOUNDS_CHECK
        to->description = c_stringNew_s(base, from->description_.c_str());
        if(to->description == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->description = c_stringNew_s(base, from->description_.c_str());
            if(to->description == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        c_string *dest0;
        const ::Mind::Termosifone::_UUIDAmbience_seq *src = &from->UUIDAmbience_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "c_string"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<c_string>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (c_string *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
#ifdef OSPL_BOUNDS_CHECK
                if((*src)[i0]){
                    dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                    if(dest0[i0] == NULL) {
                        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                    }
                } else {
                    OS_REPORT (OS_ERROR, "copyIn", 0,"Element of 'Mind::Termosifone.*src' of type 'c_string' is NULL.");
                    result = V_COPYIN_RESULT_INVALID;
                }
#else
                dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                if(dest0[i0] == NULL) {
                    result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                }
#endif
            }
            to->UUIDAmbience = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (c_string *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2080 */
            unsigned int i0;
            for (i0 = 0; (i0 < length0) && V_COPYIN_RESULT_IS_OK(result); i0++) {
#ifdef OSPL_BOUNDS_CHECK
                if((*src)[i0]){
                    dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                    if(dest0[i0] == NULL) {
                        result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                    }
                } else {
                    OS_REPORT (OS_ERROR, "copyIn", 0,"Element of 'Mind::Termosifone.*src' of type 'c_string' is NULL.");
                    result = V_COPYIN_RESULT_INVALID;
                }
#else
                dest0[i0] = c_stringNew_s(base, (*src)[i0].c_str());
                if(dest0[i0] == NULL) {
                    result = V_COPYIN_RESULT_OUT_OF_MEMORY;
                }
#endif
            }
            to->UUIDAmbience = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

void
__Mind_User_Command__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_User_Command *from = (const struct _Mind_User_Command *)_from;
    class ::Mind::User_Command *to = (class ::Mind::User_Command *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->itemCategory((::Mind::Category)from->itemCategory);
    to->command(from->command ? from->command : "");
}

void
__Mind_Item_Command__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Item_Command *from = (const struct _Mind_Item_Command *)_from;
    class ::Mind::Item_Command *to = (class ::Mind::Item_Command *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->itemCategory((::Mind::Category)from->itemCategory);
    to->command(from->command ? from->command : "");
}

void
__Mind_Actuation_Command__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Actuation_Command *from = (const struct _Mind_Actuation_Command *)_from;
    class ::Mind::Actuation_Command *to = (class ::Mind::Actuation_Command *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    {
        long size0;
        const struct _Mind_Item_Command *src0 = (const struct _Mind_Item_Command *)from->commands;
        std::vector< ::Mind::Item_Command > *dst = &to->commands();

        size0 = c_arraySize(c_sequence(from->commands));
        to->commands().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
        extern void __Mind_Item_Command__copyOut(const void *from, void *to);
                __Mind_Item_Command__copyOut((const void *)&src0[i0], (void *)&(*dst)[i0]);
            }
        }
    }
}

void
__Mind_Item_Command_Update_Category__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Item_Command_Update_Category *from = (const struct _Mind_Item_Command_Update_Category *)_from;
    class ::Mind::Item_Command_Update_Category *to = (class ::Mind::Item_Command_Update_Category *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->itemCategory((::Mind::Category)from->itemCategory);
    to->command(from->command ? from->command : "");
}

void
__Mind_Item_Consumption__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Item_Consumption *from = (const struct _Mind_Item_Consumption *)_from;
    class ::Mind::Item_Consumption *to = (class ::Mind::Item_Consumption *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
    to->itemCategory((::Mind::Category)from->itemCategory);
    to->power((double)from->power);
    to->energy((double)from->energy);
    to->timestamp((int32_t)from->timestamp);
}

void
__Mind_ExtractorFan__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_ExtractorFan *from = (const struct _Mind_ExtractorFan *)_from;
    class ::Mind::ExtractorFan *to = (class ::Mind::ExtractorFan *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->physicalLocationUUIDAmbience(from->physicalLocationUUIDAmbience ? from->physicalLocationUUIDAmbience : "");
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_VMC__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_VMC *from = (const struct _Mind_VMC *)_from;
    class ::Mind::VMC *to = (class ::Mind::VMC *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->physicalLocationUUIDAmbience(from->physicalLocationUUIDAmbience ? from->physicalLocationUUIDAmbience : "");
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_CappaAspirazione__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_CappaAspirazione *from = (const struct _Mind_CappaAspirazione *)_from;
    class ::Mind::CappaAspirazione *to = (class ::Mind::CappaAspirazione *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddressOnOff(from->MACAddressOnOff ? from->MACAddressOnOff : "");
    to->numRelayOnOff((int32_t)from->numRelayOnOff);
    to->MACAddressLight(from->MACAddressLight ? from->MACAddressLight : "");
    to->numRelayLight((int32_t)from->numRelayLight);
    to->MACAddressSpeed1(from->MACAddressSpeed1 ? from->MACAddressSpeed1 : "");
    to->numRelaySpeed1((int32_t)from->numRelaySpeed1);
    to->MACAddressSpeed2(from->MACAddressSpeed2 ? from->MACAddressSpeed2 : "");
    to->numRelaySpeed2((int32_t)from->numRelaySpeed2);
    to->MACAddressSpeed3(from->MACAddressSpeed3 ? from->MACAddressSpeed3 : "");
    to->numRelaySpeed3((int32_t)from->numRelaySpeed3);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connectedOnOff((bool)from->connectedOnOff);
    to->connectedLight((bool)from->connectedLight);
    to->connectedSpeed1((bool)from->connectedSpeed1);
    to->connectedSpeed2((bool)from->connectedSpeed2);
    to->connectedSpeed3((bool)from->connectedSpeed3);
    to->statusOnOff((int32_t)from->statusOnOff);
    to->statusLight((int32_t)from->statusLight);
    to->statusSpeed1((int32_t)from->statusSpeed1);
    to->statusSpeed2((int32_t)from->statusSpeed2);
    to->statusSpeed3((int32_t)from->statusSpeed3);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_Light__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Light *from = (const struct _Mind_Light *)_from;
    class ::Mind::Light *to = (class ::Mind::Light *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->physicalLocationUUIDAmbience(from->physicalLocationUUIDAmbience ? from->physicalLocationUUIDAmbience : "");
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_LightDimmable__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_LightDimmable *from = (const struct _Mind_LightDimmable *)_from;
    class ::Mind::LightDimmable *to = (class ::Mind::LightDimmable *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->hasFilter((bool)from->hasFilter);
    to->physicalLocationUUIDAmbience(from->physicalLocationUUIDAmbience ? from->physicalLocationUUIDAmbience : "");
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_LightMind__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_LightMind *from = (const struct _Mind_LightMind *)_from;
    class ::Mind::LightMind *to = (class ::Mind::LightMind *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->statusDimmer((int32_t)from->statusDimmer);
    to->statusTemperature((int32_t)from->statusTemperature);
    to->status((bool)from->status);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_LightMindLED__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_LightMindLED *from = (const struct _Mind_LightMindLED *)_from;
    class ::Mind::LightMindLED *to = (class ::Mind::LightMindLED *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->status((bool)from->status);
    to->r((int32_t)from->r);
    to->g((int32_t)from->g);
    to->b((int32_t)from->b);
    to->w((int32_t)from->w);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_BSwitch__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_BSwitch *from = (const struct _Mind_BSwitch *)_from;
    class ::Mind::BSwitch *to = (class ::Mind::BSwitch *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numInput((int32_t)from->numInput);
    to->status((int32_t)from->status);
    to->connected((bool)from->connected);
    to->disabled((bool)from->disabled);
    to->description(from->description ? from->description : "");
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_Button__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Button *from = (const struct _Mind_Button *)_from;
    class ::Mind::Button *to = (class ::Mind::Button *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numInput((int32_t)from->numInput);
    to->status((int32_t)from->status);
    to->connected((bool)from->connected);
    to->disabled((bool)from->disabled);
    to->description(from->description ? from->description : "");
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_ShutterButton__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_ShutterButton *from = (const struct _Mind_ShutterButton *)_from;
    class ::Mind::ShutterButton *to = (class ::Mind::ShutterButton *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->UUIDShutter(from->UUIDShutter ? from->UUIDShutter : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numInput((int32_t)from->numInput);
    to->status((int32_t)from->status);
    to->connected((bool)from->connected);
    to->disabled((bool)from->disabled);
    to->description(from->description ? from->description : "");
    to->updownType((bool)from->updownType);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_DoorContact__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_DoorContact *from = (const struct _Mind_DoorContact *)_from;
    class ::Mind::DoorContact *to = (class ::Mind::DoorContact *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numInput((int32_t)from->numInput);
    to->status((int32_t)from->status);
    to->connected((bool)from->connected);
    to->description(from->description ? from->description : "");
    to->disabled((bool)from->disabled);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_WindowContact__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_WindowContact *from = (const struct _Mind_WindowContact *)_from;
    class ::Mind::WindowContact *to = (class ::Mind::WindowContact *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numInput((int32_t)from->numInput);
    to->status((int32_t)from->status);
    to->connected((bool)from->connected);
    to->description(from->description ? from->description : "");
    to->disabled((bool)from->disabled);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_Tamper__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Tamper *from = (const struct _Mind_Tamper *)_from;
    class ::Mind::Tamper *to = (class ::Mind::Tamper *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numInput((int32_t)from->numInput);
    to->status((int32_t)from->status);
    to->connected((bool)from->connected);
    to->description(from->description ? from->description : "");
    to->disabled((bool)from->disabled);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_PIRContact__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_PIRContact *from = (const struct _Mind_PIRContact *)_from;
    class ::Mind::PIRContact *to = (class ::Mind::PIRContact *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numInput((int32_t)from->numInput);
    to->status((int32_t)from->status);
    to->connected((bool)from->connected);
    to->description(from->description ? from->description : "");
    to->disabled((bool)from->disabled);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_RollerShutter__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_RollerShutter *from = (const struct _Mind_RollerShutter *)_from;
    class ::Mind::RollerShutter *to = (class ::Mind::RollerShutter *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->status((int32_t)from->status);
    to->numRelay((int32_t)from->numRelay);
    to->connected((bool)from->connected);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_Scuro__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Scuro *from = (const struct _Mind_Scuro *)_from;
    class ::Mind::Scuro *to = (class ::Mind::Scuro *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->status((int32_t)from->status);
    to->numRelay((int32_t)from->numRelay);
    to->connected((bool)from->connected);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_Frangisole__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Frangisole *from = (const struct _Mind_Frangisole *)_from;
    class ::Mind::Frangisole *to = (class ::Mind::Frangisole *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->status((int32_t)from->status);
    to->numRelay((int32_t)from->numRelay);
    to->connected((bool)from->connected);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_Blinds__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Blinds *from = (const struct _Mind_Blinds *)_from;
    class ::Mind::Blinds *to = (class ::Mind::Blinds *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->status((int32_t)from->status);
    to->numRelay((int32_t)from->numRelay);
    to->connected((bool)from->connected);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_Veneziana__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Veneziana *from = (const struct _Mind_Veneziana *)_from;
    class ::Mind::Veneziana *to = (class ::Mind::Veneziana *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->status((int32_t)from->status);
    to->numRelay((int32_t)from->numRelay);
    to->connected((bool)from->connected);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_Grata__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Grata *from = (const struct _Mind_Grata *)_from;
    class ::Mind::Grata *to = (class ::Mind::Grata *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->status((int32_t)from->status);
    to->numRelay((int32_t)from->numRelay);
    to->connected((bool)from->connected);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_Forno__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Forno *from = (const struct _Mind_Forno *)_from;
    class ::Mind::Forno *to = (class ::Mind::Forno *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_FornoMicroonde__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_FornoMicroonde *from = (const struct _Mind_FornoMicroonde *)_from;
    class ::Mind::FornoMicroonde *to = (class ::Mind::FornoMicroonde *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_Frigo__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Frigo *from = (const struct _Mind_Frigo *)_from;
    class ::Mind::Frigo *to = (class ::Mind::Frigo *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_Freezer__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Freezer *from = (const struct _Mind_Freezer *)_from;
    class ::Mind::Freezer *to = (class ::Mind::Freezer *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_CantinaVini__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_CantinaVini *from = (const struct _Mind_CantinaVini *)_from;
    class ::Mind::CantinaVini *to = (class ::Mind::CantinaVini *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_MacchinaCaffe__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_MacchinaCaffe *from = (const struct _Mind_MacchinaCaffe *)_from;
    class ::Mind::MacchinaCaffe *to = (class ::Mind::MacchinaCaffe *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_PianoCottura__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_PianoCottura *from = (const struct _Mind_PianoCottura *)_from;
    class ::Mind::PianoCottura *to = (class ::Mind::PianoCottura *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_Lavatrice__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Lavatrice *from = (const struct _Mind_Lavatrice *)_from;
    class ::Mind::Lavatrice *to = (class ::Mind::Lavatrice *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_Lavastoviglie__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Lavastoviglie *from = (const struct _Mind_Lavastoviglie *)_from;
    class ::Mind::Lavastoviglie *to = (class ::Mind::Lavastoviglie *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_Asciugatrice__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Asciugatrice *from = (const struct _Mind_Asciugatrice *)_from;
    class ::Mind::Asciugatrice *to = (class ::Mind::Asciugatrice *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_ColonnettaTesla__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_ColonnettaTesla *from = (const struct _Mind_ColonnettaTesla *)_from;
    class ::Mind::ColonnettaTesla *to = (class ::Mind::ColonnettaTesla *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_Impianto__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Impianto *from = (const struct _Mind_Impianto *)_from;
    class ::Mind::Impianto *to = (class ::Mind::Impianto *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_IrrigationPump__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_IrrigationPump *from = (const struct _Mind_IrrigationPump *)_from;
    class ::Mind::IrrigationPump *to = (class ::Mind::IrrigationPump *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_Siren__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Siren *from = (const struct _Mind_Siren *)_from;
    class ::Mind::Siren *to = (class ::Mind::Siren *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_CancelloCarraio__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_CancelloCarraio *from = (const struct _Mind_CancelloCarraio *)_from;
    class ::Mind::CancelloCarraio *to = (class ::Mind::CancelloCarraio *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_CancelloPedonale__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_CancelloPedonale *from = (const struct _Mind_CancelloPedonale *)_from;
    class ::Mind::CancelloPedonale *to = (class ::Mind::CancelloPedonale *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_CancelloGarage__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_CancelloGarage *from = (const struct _Mind_CancelloGarage *)_from;
    class ::Mind::CancelloGarage *to = (class ::Mind::CancelloGarage *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_GasValve__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_GasValve *from = (const struct _Mind_GasValve *)_from;
    class ::Mind::GasValve *to = (class ::Mind::GasValve *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_WaterValve__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_WaterValve *from = (const struct _Mind_WaterValve *)_from;
    class ::Mind::WaterValve *to = (class ::Mind::WaterValve *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_PompaRicircolo__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_PompaRicircolo *from = (const struct _Mind_PompaRicircolo *)_from;
    class ::Mind::PompaRicircolo *to = (class ::Mind::PompaRicircolo *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_Socket_16A__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Socket_16A *from = (const struct _Mind_Socket_16A *)_from;
    class ::Mind::Socket_16A *to = (class ::Mind::Socket_16A *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->physicalLocationUUIDAmbience(from->physicalLocationUUIDAmbience ? from->physicalLocationUUIDAmbience : "");
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_Socket_5A__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Socket_5A *from = (const struct _Mind_Socket_5A *)_from;
    class ::Mind::Socket_5A *to = (class ::Mind::Socket_5A *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->hasFilter((bool)from->hasFilter);
    to->physicalLocationUUIDAmbience(from->physicalLocationUUIDAmbience ? from->physicalLocationUUIDAmbience : "");
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_VoiceCommand__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_VoiceCommand *from = (const struct _Mind_VoiceCommand *)_from;
    class ::Mind::VoiceCommand *to = (class ::Mind::VoiceCommand *)_to;
    to->text(from->text ? from->text : "");
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_PresaMultimediale__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_PresaMultimediale *from = (const struct _Mind_PresaMultimediale *)_from;
    class ::Mind::PresaMultimediale *to = (class ::Mind::PresaMultimediale *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_HarmonyMultimedia__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_HarmonyMultimedia *from = (const struct _Mind_HarmonyMultimedia *)_from;
    class ::Mind::HarmonyMultimedia *to = (class ::Mind::HarmonyMultimedia *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->IPAddress(from->IPAddress ? from->IPAddress : "");
    to->currentActivity(from->currentActivity ? from->currentActivity : "");
    {
        long size0;
        const c_string *src0 = (const c_string *)from->availableActivities;
        std::vector< std::string > *dst = &to->availableActivities();

        size0 = c_arraySize(c_sequence(from->availableActivities));
        to->availableActivities().clear();
        to->availableActivities().reserve(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst).push_back(src0[i0] ? src0[i0] : "");
            }
        }
    }
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->name(from->name ? from->name : "");
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_MindSound__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_MindSound *from = (const struct _Mind_MindSound *)_from;
    class ::Mind::MindSound *to = (class ::Mind::MindSound *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->currentSound(from->currentSound ? from->currentSound : "");
    to->enabled((bool)from->enabled);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_TransportData__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_TransportData *from = (const struct _Mind_TransportData *)_from;
    class ::Mind::TransportData *to = (class ::Mind::TransportData *)_to;
    to->title(from->title ? from->title : "");
    to->artist(from->artist ? from->artist : "");
    to->uri(from->uri ? from->uri : "");
    to->queueSize((int32_t)from->queueSize);
    to->currentTrackDuration(from->currentTrackDuration ? from->currentTrackDuration : "");
    to->CurrentTransportActions(from->CurrentTransportActions ? from->CurrentTransportActions : "");
    to->status((::Mind::TransportStatus)from->status);
}

void
__Mind_RenderingData__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_RenderingData *from = (const struct _Mind_RenderingData *)_from;
    class ::Mind::RenderingData *to = (class ::Mind::RenderingData *)_to;
    to->volumeMaster((int32_t)from->volumeMaster);
    to->volumeLF((int32_t)from->volumeLF);
    to->volumeRF((int32_t)from->volumeRF);
    to->muteMaster((bool)from->muteMaster);
    to->muteLF((bool)from->muteLF);
    to->muteRF((bool)from->muteRF);
}

void
__Mind_Sonos__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Sonos *from = (const struct _Mind_Sonos *)_from;
    class ::Mind::Sonos *to = (class ::Mind::Sonos *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->zoneName(from->zoneName ? from->zoneName : "");
    to->uri(from->uri ? from->uri : "");
    to->coordinatorUUID(from->coordinatorUUID ? from->coordinatorUUID : "");
    {
        extern void __Mind_TransportData__copyOut(const void *, void *);
        ::Mind::TransportData &tmp = to->transportData();
        __Mind_TransportData__copyOut((const void *)&from->transportData, &tmp);
    }
    {
        extern void __Mind_RenderingData__copyOut(const void *, void *);
        ::Mind::RenderingData &tmp = to->renderingData();
        __Mind_RenderingData__copyOut((const void *)&from->renderingData, &tmp);
    }
    to->connected((bool)from->connected);
    to->enabled((bool)from->enabled);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_ProjectionScreen__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_ProjectionScreen *from = (const struct _Mind_ProjectionScreen *)_from;
    class ::Mind::ProjectionScreen *to = (class ::Mind::ProjectionScreen *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->status((int32_t)from->status);
    to->numRelay((int32_t)from->numRelay);
    to->connected((bool)from->connected);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_Citofono__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Citofono *from = (const struct _Mind_Citofono *)_from;
    class ::Mind::Citofono *to = (class ::Mind::Citofono *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->IPAddress(from->IPAddress ? from->IPAddress : "");
    to->description(from->description ? from->description : "");
    to->status((bool)from->status);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_FloodingSensor__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_FloodingSensor *from = (const struct _Mind_FloodingSensor *)_from;
    class ::Mind::FloodingSensor *to = (class ::Mind::FloodingSensor *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->IPAddress(from->IPAddress ? from->IPAddress : "");
    to->description(from->description ? from->description : "");
    to->status((bool)from->status);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_EnvironmentalSensor__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_EnvironmentalSensor *from = (const struct _Mind_EnvironmentalSensor *)_from;
    class ::Mind::EnvironmentalSensor *to = (class ::Mind::EnvironmentalSensor *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->temperature((double)from->temperature);
    to->CO((double)from->CO);
    to->CO2((double)from->CO2);
    to->humidity((double)from->humidity);
    to->VOC((double)from->VOC);
    to->smoke((double)from->smoke);
    to->timestamp(from->timestamp ? from->timestamp : "");
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_VisionEnvironmentalSensor__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_VisionEnvironmentalSensor *from = (const struct _Mind_VisionEnvironmentalSensor *)_from;
    class ::Mind::VisionEnvironmentalSensor *to = (class ::Mind::VisionEnvironmentalSensor *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->brightness((double)from->brightness);
    to->motion((double)from->motion);
    to->timestamp(from->timestamp ? from->timestamp : "");
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_VisionPeopleSensor__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_VisionPeopleSensor *from = (const struct _Mind_VisionPeopleSensor *)_from;
    class ::Mind::VisionPeopleSensor *to = (class ::Mind::VisionPeopleSensor *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->peopleCount((int32_t)from->peopleCount);
    to->knownPeopleCount((int32_t)from->knownPeopleCount);
    to->unknownPeopleCount((int32_t)from->unknownPeopleCount);
    to->faceCount((int32_t)from->faceCount);
    to->timestamp(from->timestamp ? from->timestamp : "");
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_PowerSensor__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_PowerSensor *from = (const struct _Mind_PowerSensor *)_from;
    class ::Mind::PowerSensor *to = (class ::Mind::PowerSensor *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->consumption((double)from->consumption);
    to->timestamp(from->timestamp ? from->timestamp : "");
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_BluetoothIdentitySensor__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_BluetoothIdentitySensor *from = (const struct _Mind_BluetoothIdentitySensor *)_from;
    class ::Mind::BluetoothIdentitySensor *to = (class ::Mind::BluetoothIdentitySensor *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->probability((double)from->probability);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_VisionIdentitySensor__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_VisionIdentitySensor *from = (const struct _Mind_VisionIdentitySensor *)_from;
    class ::Mind::VisionIdentitySensor *to = (class ::Mind::VisionIdentitySensor *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->probability((double)from->probability);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_Thermostat__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Thermostat *from = (const struct _Mind_Thermostat *)_from;
    class ::Mind::Thermostat *to = (class ::Mind::Thermostat *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->targetTemperature((double)from->targetTemperature);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_CurrentWeather__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_CurrentWeather *from = (const struct _Mind_CurrentWeather *)_from;
    class ::Mind::CurrentWeather *to = (class ::Mind::CurrentWeather *)_to;
    to->referenceTimestamp((int32_t)from->referenceTimestamp);
    to->temperature((double)from->temperature);
    to->pressure((double)from->pressure);
    to->humidity((double)from->humidity);
    to->windKph((double)from->windKph);
    to->uv((double)from->uv);
    to->cloudiness((int32_t)from->cloudiness);
    to->conditionCode((int32_t)from->conditionCode);
    to->conditionName(from->conditionName ? from->conditionName : "");
    to->nextSunrise(from->nextSunrise ? from->nextSunrise : "");
    to->nextSunset(from->nextSunset ? from->nextSunset : "");
}

void
__Mind_HourlyWeatherData__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_HourlyWeatherData *from = (const struct _Mind_HourlyWeatherData *)_from;
    class ::Mind::HourlyWeatherData *to = (class ::Mind::HourlyWeatherData *)_to;
    to->referenceTimestamp((int32_t)from->referenceTimestamp);
    to->windKph((double)from->windKph);
    to->temperature((double)from->temperature);
    to->rainChance((int32_t)from->rainChance);
    to->willItRain((bool)from->willItRain);
    to->isDay((bool)from->isDay);
    to->conditionCode((int32_t)from->conditionCode);
    to->conditionName(from->conditionName ? from->conditionName : "");
    to->cloudiness((int32_t)from->cloudiness);
    to->precipMm((double)from->precipMm);
}

void
__Mind_DailyWeatherData__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_DailyWeatherData *from = (const struct _Mind_DailyWeatherData *)_from;
    class ::Mind::DailyWeatherData *to = (class ::Mind::DailyWeatherData *)_to;
    to->referenceTimestamp((int32_t)from->referenceTimestamp);
    to->maxTemperature((double)from->maxTemperature);
    to->temperature((double)from->temperature);
    to->minTemperature((double)from->minTemperature);
    to->precipMm((double)from->precipMm);
    to->conditionCode((int32_t)from->conditionCode);
    to->conditionName(from->conditionName ? from->conditionName : "");
    to->uv((double)from->uv);
}

void
__Mind_HistoricalAndForecastedWeather__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_HistoricalAndForecastedWeather *from = (const struct _Mind_HistoricalAndForecastedWeather *)_from;
    class ::Mind::HistoricalAndForecastedWeather *to = (class ::Mind::HistoricalAndForecastedWeather *)_to;
    to->lastUpdateTimestamp((int32_t)from->lastUpdateTimestamp);
    {
        extern void __Mind_DailyWeatherData__copyOut(const void *, void *);
        ::Mind::DailyWeatherData &tmp = to->tomorrow();
        __Mind_DailyWeatherData__copyOut((const void *)&from->tomorrow, &tmp);
    }
    {
        extern void __Mind_DailyWeatherData__copyOut(const void *, void *);
        ::Mind::DailyWeatherData &tmp = to->today();
        __Mind_DailyWeatherData__copyOut((const void *)&from->today, &tmp);
    }
    {
        extern void __Mind_DailyWeatherData__copyOut(const void *, void *);
        ::Mind::DailyWeatherData &tmp = to->yesterday();
        __Mind_DailyWeatherData__copyOut((const void *)&from->yesterday, &tmp);
    }
    {
        long size0;
        const struct _Mind_HourlyWeatherData *src0 = (const struct _Mind_HourlyWeatherData *)from->hourlyForecast;
        std::vector< ::Mind::HourlyWeatherData > *dst = &to->hourlyForecast();

        size0 = c_arraySize(c_sequence(from->hourlyForecast));
        to->hourlyForecast().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
        extern void __Mind_HourlyWeatherData__copyOut(const void *from, void *to);
                __Mind_HourlyWeatherData__copyOut((const void *)&src0[i0], (void *)&(*dst)[i0]);
            }
        }
    }
    {
        long size0;
        const struct _Mind_HourlyWeatherData *src0 = (const struct _Mind_HourlyWeatherData *)from->hourlyHistory;
        std::vector< ::Mind::HourlyWeatherData > *dst = &to->hourlyHistory();

        size0 = c_arraySize(c_sequence(from->hourlyHistory));
        to->hourlyHistory().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
        extern void __Mind_HourlyWeatherData__copyOut(const void *from, void *to);
                __Mind_HourlyWeatherData__copyOut((const void *)&src0[i0], (void *)&(*dst)[i0]);
            }
        }
    }
}

void
__Mind_Caldaia__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Caldaia *from = (const struct _Mind_Caldaia *)_from;
    class ::Mind::Caldaia *to = (class ::Mind::Caldaia *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_PompaCalore__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_PompaCalore *from = (const struct _Mind_PompaCalore *)_from;
    class ::Mind::PompaCalore *to = (class ::Mind::PompaCalore *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddressOnOff(from->MACAddressOnOff ? from->MACAddressOnOff : "");
    to->numRelayOnOff((int32_t)from->numRelayOnOff);
    to->MACAddressCF(from->MACAddressCF ? from->MACAddressCF : "");
    to->numRelayCF((int32_t)from->numRelayCF);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connectedOnOff((bool)from->connectedOnOff);
    to->connectedCF((bool)from->connectedCF);
    to->statusOnOff((bool)from->statusOnOff);
    to->statusCF((bool)from->statusCF);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_FloorHeating__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_FloorHeating *from = (const struct _Mind_FloorHeating *)_from;
    class ::Mind::FloorHeating *to = (class ::Mind::FloorHeating *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    {
        long size0;
        const c_string *src0 = (const c_string *)from->UUIDAmbiences;
        std::vector< std::string > *dst = &to->UUIDAmbiences();

        size0 = c_arraySize(c_sequence(from->UUIDAmbiences));
        to->UUIDAmbiences().clear();
        to->UUIDAmbiences().reserve(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst).push_back(src0[i0] ? src0[i0] : "");
            }
        }
    }
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_FanCoil__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_FanCoil *from = (const struct _Mind_FanCoil *)_from;
    class ::Mind::FanCoil *to = (class ::Mind::FanCoil *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->description(from->description ? from->description : "");
    to->MACAddressOnOff(from->MACAddressOnOff ? from->MACAddressOnOff : "");
    to->numRelayOnOff((int32_t)from->numRelayOnOff);
    to->MACAddressSpeed1(from->MACAddressSpeed1 ? from->MACAddressSpeed1 : "");
    to->numRelaySpeed1((int32_t)from->numRelaySpeed1);
    to->MACAddressSpeed2(from->MACAddressSpeed2 ? from->MACAddressSpeed2 : "");
    to->numRelaySpeed2((int32_t)from->numRelaySpeed2);
    to->MACAddressSpeed3(from->MACAddressSpeed3 ? from->MACAddressSpeed3 : "");
    to->numRelaySpeed3((int32_t)from->numRelaySpeed3);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connectedOnOff((bool)from->connectedOnOff);
    to->connectedSpeed1((bool)from->connectedSpeed1);
    to->connectedSpeed2((bool)from->connectedSpeed2);
    to->connectedSpeed3((bool)from->connectedSpeed3);
    to->statusOnOff((int32_t)from->statusOnOff);
    to->statusSpeed1((int32_t)from->statusSpeed1);
    to->statusSpeed2((int32_t)from->statusSpeed2);
    to->statusSpeed3((int32_t)from->statusSpeed3);
    to->blocked((bool)from->blocked);
    {
        long size0;
        const c_string *src0 = (const c_string *)from->UUIDAmbiences;
        std::vector< std::string > *dst = &to->UUIDAmbiences();

        size0 = c_arraySize(c_sequence(from->UUIDAmbiences));
        to->UUIDAmbiences().clear();
        to->UUIDAmbiences().reserve(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst).push_back(src0[i0] ? src0[i0] : "");
            }
        }
    }
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_CoolingFan__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_CoolingFan *from = (const struct _Mind_CoolingFan *)_from;
    class ::Mind::CoolingFan *to = (class ::Mind::CoolingFan *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddress(from->MACAddress ? from->MACAddress : "");
    to->numRelay((int32_t)from->numRelay);
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->connected((bool)from->connected);
    to->status((int32_t)from->status);
    to->description(from->description ? from->description : "");
    to->blocked((bool)from->blocked);
    to->physicalLocationUUIDAmbience(from->physicalLocationUUIDAmbience ? from->physicalLocationUUIDAmbience : "");
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_HarmonySplit__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_HarmonySplit *from = (const struct _Mind_HarmonySplit *)_from;
    class ::Mind::HarmonySplit *to = (class ::Mind::HarmonySplit *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->IPAddress(from->IPAddress ? from->IPAddress : "");
    to->description(from->description ? from->description : "");
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->temperature((int32_t)from->temperature);
    to->deumidifica((bool)from->deumidifica);
    to->speed((int32_t)from->speed);
    to->airOrientation((int32_t)from->airOrientation);
    {
        long size0;
        const c_string *src0 = (const c_string *)from->UUIDAmbience;
        std::vector< std::string > *dst = &to->UUIDAmbience();

        size0 = c_arraySize(c_sequence(from->UUIDAmbience));
        to->UUIDAmbience().clear();
        to->UUIDAmbience().reserve(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst).push_back(src0[i0] ? src0[i0] : "");
            }
        }
    }
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

void
__Mind_Termosifone__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Termosifone *from = (const struct _Mind_Termosifone *)_from;
    class ::Mind::Termosifone *to = (class ::Mind::Termosifone *)_to;
    to->UUID(from->UUID ? from->UUID : "");
    to->MACAddressBT(from->MACAddressBT ? from->MACAddressBT : "");
    {
        long size0;
        const enum _Mind_Category *src0 = (const enum _Mind_Category *)from->categories;
        std::vector< ::Mind::Category > *dst = &to->categories();

        size0 = c_arraySize(c_sequence(from->categories));
        to->categories().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst)[i0] = (::Mind::Category)src0[i0];
            }
        }
    }
    to->batteryStatus((double)from->batteryStatus);
    to->connected((bool)from->connected);
    to->status((bool)from->status);
    to->description(from->description ? from->description : "");
    {
        long size0;
        const c_string *src0 = (const c_string *)from->UUIDAmbience;
        std::vector< std::string > *dst = &to->UUIDAmbience();

        size0 = c_arraySize(c_sequence(from->UUIDAmbience));
        to->UUIDAmbience().clear();
        to->UUIDAmbience().reserve(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
                (*dst).push_back(src0[i0] ? src0[i0] : "");
            }
        }
    }
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

