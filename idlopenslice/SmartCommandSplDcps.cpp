#include "SmartCommand_DCPS.hpp"

#include <v_copyIn.h>
#include <v_topic.h>
#include <os_stdlib.h>
#include <string.h>
#include <os_report.h>

v_copyin_result
__Mind_SmartCommand__copyIn(
    c_base base,
    const class ::Mind::SmartCommand *from,
    struct _Mind_SmartCommand *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
    if((((c_long)from->commandType_) >= 0) && (((c_long)from->commandType_) < 10) ){
        to->commandType = (enum _Mind_SmartCommandType)from->commandType_;
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'Mind::SmartCommand.commandType' of type 'SmartCommandType' is out of range.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->commandType = (enum _Mind_SmartCommandType)from->commandType_;
#endif
    to->position = (c_long)from->position_;
    return result;
}

v_copyin_result
__Mind_Ambience_SmartCommandSettings__copyIn(
    c_base base,
    const class ::Mind::Ambience_SmartCommandSettings *from,
    struct _Mind_Ambience_SmartCommandSettings *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

    {
/* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 826 */

        static c_type type0 = NULL;
        c_type subtype0;
        c_ulong length0;
        struct _Mind_SmartCommand *dest0;
        const ::Mind::Ambience_SmartCommandSettings::_smartCommands_seq *src = &from->smartCommands_;

        if (type0 == NULL) {
            subtype0 = c_type(c_metaResolve (c_metaObject(base), "Mind::SmartCommand"));
            type0 = c_metaSequenceTypeNew(c_metaObject(base),"C_SEQUENCE<Mind::SmartCommand>",subtype0,0);
            c_free(subtype0);
        }
        length0 = (c_ulong)(*src).size();
#ifdef OSPL_BOUNDS_CHECK
         dest0 = (struct _Mind_SmartCommand *)c_newSequence_s(c_collectionType(type0),length0);
         if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const struct _Mind_SmartCommand *buf0;
                buf0 = reinterpret_cast<const struct _Mind_SmartCommand *>(&((*src)[0]));
                memcpy (dest0,buf0,length0* sizeof(*dest0));
            }
            to->smartCommands = (c_sequence)dest0;
         } else {
             result = V_COPYIN_RESULT_OUT_OF_MEMORY;
          }
#else
        dest0 = (struct _Mind_SmartCommand *)c_newSequence_s(c_collectionType(type0),length0);
        if(dest0 != NULL) {
            /* Code generated by /home/dds/OvernightTests/overnight/ospli/heads/OSPL_V6_8-02-branch/ubuntu1604-64a/x86_64.linux-release-inner/build/src/tools/idlpp/code/idl_genCorbaCxxCopyin.c at line 2025 */
            if(length0 > 0)
            {
                const struct _Mind_SmartCommand *buf0;
                buf0 = reinterpret_cast<const struct _Mind_SmartCommand *>(&((*src)[0]));
                memcpy (dest0,buf0,length0* sizeof(*dest0));
            }
            to->smartCommands = (c_sequence)dest0;
        } else {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#endif
    }
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

v_copyin_result
__Mind_Command_Trigger_SmartCommand__copyIn(
    c_base base,
    const class ::Mind::Command_Trigger_SmartCommand *from,
    struct _Mind_Command_Trigger_SmartCommand *to)
{
    v_copyin_result result = V_COPYIN_RESULT_OK;
    (void) base;

#ifdef OSPL_BOUNDS_CHECK
    if((((c_long)from->smartCommand_) >= 0) && (((c_long)from->smartCommand_) < 10) ){
        to->smartCommand = (enum _Mind_SmartCommandType)from->smartCommand_;
    } else {
        OS_REPORT (OS_ERROR, "copyIn", 0,"Member 'Mind::Command_Trigger_SmartCommand.smartCommand' of type 'SmartCommandType' is out of range.");
        result = V_COPYIN_RESULT_INVALID;
    }
#else
    to->smartCommand = (enum _Mind_SmartCommandType)from->smartCommand_;
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->command = c_stringNew_s(base, from->command_.c_str());
        if(to->command == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->command = c_stringNew_s(base, from->command_.c_str());
            if(to->command == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
        if(to->UUIDAmbience == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDAmbience = c_stringNew_s(base, from->UUIDAmbience_.c_str());
            if(to->UUIDAmbience == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
        if(to->UUIDRoom == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDRoom = c_stringNew_s(base, from->UUIDRoom_.c_str());
            if(to->UUIDRoom == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
        if(to->UUIDFloor == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDFloor = c_stringNew_s(base, from->UUIDFloor_.c_str());
            if(to->UUIDFloor == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
#ifdef OSPL_BOUNDS_CHECK
        to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
        if(to->UUIDHouse == NULL) {
            result = V_COPYIN_RESULT_OUT_OF_MEMORY;
        }
#else
            to->UUIDHouse = c_stringNew_s(base, from->UUIDHouse_.c_str());
            if(to->UUIDHouse == NULL) {
                result = V_COPYIN_RESULT_OUT_OF_MEMORY;
            }
#endif
    return result;
}

void
__Mind_SmartCommand__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_SmartCommand *from = (const struct _Mind_SmartCommand *)_from;
    class ::Mind::SmartCommand *to = (class ::Mind::SmartCommand *)_to;
    to->commandType((::Mind::SmartCommandType)from->commandType);
    to->position((int32_t)from->position);
}

void
__Mind_Ambience_SmartCommandSettings__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Ambience_SmartCommandSettings *from = (const struct _Mind_Ambience_SmartCommandSettings *)_from;
    class ::Mind::Ambience_SmartCommandSettings *to = (class ::Mind::Ambience_SmartCommandSettings *)_to;
    {
        long size0;
        const struct _Mind_SmartCommand *src0 = (const struct _Mind_SmartCommand *)from->smartCommands;
        std::vector< ::Mind::SmartCommand > *dst = &to->smartCommands();

        size0 = c_arraySize(c_sequence(from->smartCommands));
        to->smartCommands().resize(size0);
        {
            long i0;
            for (i0 = 0; i0 < size0; i0++) {
        extern void __Mind_SmartCommand__copyOut(const void *from, void *to);
                __Mind_SmartCommand__copyOut((const void *)&src0[i0], (void *)&(*dst)[i0]);
            }
        }
    }
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
}

void
__Mind_Command_Trigger_SmartCommand__copyOut(
    const void *_from,
    void *_to)
{
    const struct _Mind_Command_Trigger_SmartCommand *from = (const struct _Mind_Command_Trigger_SmartCommand *)_from;
    class ::Mind::Command_Trigger_SmartCommand *to = (class ::Mind::Command_Trigger_SmartCommand *)_to;
    to->smartCommand((::Mind::SmartCommandType)from->smartCommand);
    to->command(from->command ? from->command : "");
    to->UUIDAmbience(from->UUIDAmbience ? from->UUIDAmbience : "");
    to->UUIDRoom(from->UUIDRoom ? from->UUIDRoom : "");
    to->UUIDFloor(from->UUIDFloor ? from->UUIDFloor : "");
    to->UUIDHouse(from->UUIDHouse ? from->UUIDHouse : "");
}

